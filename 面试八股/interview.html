<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title> 面试八股 | 不为无益之事，安能悦有涯之生.</title>
    <meta name="generator" content="VuePress 1.9.9">
    <link rel="icon" href="/img/favicon.ico">
    <link rel="stylesheet" href="/css/style.css">
    <script charset="utf-8" src="/js/custom.js"></script>
    <meta name="description" content="左当风谷，右临云溪。上无凌虚之巢，下无跖实之蹊。">
    <meta name="keywords" content="跖蹊的个人小站,vuepress,自建博客,跖蹊">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
    <meta name="robots" content="all">
    <meta name="author" content="跖蹊">
    
    <link rel="preload" href="/assets/css/0.styles.792068da.css" as="style"><link rel="preload" href="/assets/js/app.61e9cc92.js" as="script"><link rel="preload" href="/assets/js/3.95481a90.js" as="script"><link rel="preload" href="/assets/js/1.1954234d.js" as="script"><link rel="preload" href="/assets/js/53.a90f2ab6.js" as="script"><link rel="prefetch" href="/assets/js/10.f7052a78.js"><link rel="prefetch" href="/assets/js/11.3cab4bfb.js"><link rel="prefetch" href="/assets/js/12.4f0d11a3.js"><link rel="prefetch" href="/assets/js/13.678060fc.js"><link rel="prefetch" href="/assets/js/14.ee30aa1d.js"><link rel="prefetch" href="/assets/js/15.f3376218.js"><link rel="prefetch" href="/assets/js/16.00f69dbe.js"><link rel="prefetch" href="/assets/js/17.2940f5bd.js"><link rel="prefetch" href="/assets/js/18.4ecdd86c.js"><link rel="prefetch" href="/assets/js/19.16672354.js"><link rel="prefetch" href="/assets/js/20.3012acd3.js"><link rel="prefetch" href="/assets/js/21.e142ce0d.js"><link rel="prefetch" href="/assets/js/22.970bd9e4.js"><link rel="prefetch" href="/assets/js/23.f5c69fe1.js"><link rel="prefetch" href="/assets/js/24.99f14eef.js"><link rel="prefetch" href="/assets/js/25.16ef62ca.js"><link rel="prefetch" href="/assets/js/26.12956cd1.js"><link rel="prefetch" href="/assets/js/27.efbbf378.js"><link rel="prefetch" href="/assets/js/28.cdea7360.js"><link rel="prefetch" href="/assets/js/29.ae534eab.js"><link rel="prefetch" href="/assets/js/30.67738dff.js"><link rel="prefetch" href="/assets/js/31.f38b5468.js"><link rel="prefetch" href="/assets/js/32.d4d5a623.js"><link rel="prefetch" href="/assets/js/33.6d730e7a.js"><link rel="prefetch" href="/assets/js/34.fd1251bd.js"><link rel="prefetch" href="/assets/js/35.df6298b6.js"><link rel="prefetch" href="/assets/js/36.9722fc71.js"><link rel="prefetch" href="/assets/js/37.b41d506f.js"><link rel="prefetch" href="/assets/js/38.223a5148.js"><link rel="prefetch" href="/assets/js/39.83218678.js"><link rel="prefetch" href="/assets/js/4.42fbd73a.js"><link rel="prefetch" href="/assets/js/40.b6fde60b.js"><link rel="prefetch" href="/assets/js/41.775defc1.js"><link rel="prefetch" href="/assets/js/42.0a544acc.js"><link rel="prefetch" href="/assets/js/43.2a20598b.js"><link rel="prefetch" href="/assets/js/44.e5b8564c.js"><link rel="prefetch" href="/assets/js/45.04d21485.js"><link rel="prefetch" href="/assets/js/46.09dd026c.js"><link rel="prefetch" href="/assets/js/47.b503326c.js"><link rel="prefetch" href="/assets/js/48.ffae2522.js"><link rel="prefetch" href="/assets/js/49.f6e1c9bb.js"><link rel="prefetch" href="/assets/js/5.027f47d8.js"><link rel="prefetch" href="/assets/js/50.eb1fe7ba.js"><link rel="prefetch" href="/assets/js/51.e9375d1a.js"><link rel="prefetch" href="/assets/js/52.1ca5d29b.js"><link rel="prefetch" href="/assets/js/6.48943115.js"><link rel="prefetch" href="/assets/js/7.671be9fe.js"><link rel="prefetch" href="/assets/js/8.8329d681.js"><link rel="prefetch" href="/assets/js/9.bf7cd993.js">
    <link rel="stylesheet" href="/assets/css/0.styles.792068da.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div><div class="theme-container" data-v-4698c43e><div data-v-4698c43e><div id="loader-wrapper" class="loading-wrapper" data-v-1c4f0192 data-v-4698c43e data-v-4698c43e><div class="loader-main" data-v-1c4f0192><div data-v-1c4f0192></div><div data-v-1c4f0192></div><div data-v-1c4f0192></div><div data-v-1c4f0192></div></div> <!----> <!----></div> <div class="password-shadow password-wrapper-out" style="display:none;" data-v-6cbeab0a data-v-4698c43e data-v-4698c43e><h3 class="title" style="display:none;" data-v-6cbeab0a data-v-6cbeab0a>不为无益之事，安能悦有涯之生.</h3> <!----> <label id="box" class="inputBox" style="display:none;" data-v-6cbeab0a data-v-6cbeab0a><input type="password" value="" data-v-6cbeab0a> <span data-v-6cbeab0a>Konck! Knock!</span> <button data-v-6cbeab0a>OK</button></label> <div class="footer" style="display:none;" data-v-6cbeab0a data-v-6cbeab0a><span data-v-6cbeab0a><i class="iconfont reco-theme" data-v-6cbeab0a></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-6cbeab0a>vuePress-theme-reco</a></span> <span data-v-6cbeab0a><i class="iconfont reco-copyright" data-v-6cbeab0a></i> <a data-v-6cbeab0a><span data-v-6cbeab0a>跖蹊</span>
            
          <span data-v-6cbeab0a>2022 - </span>
          2023
        </a></span></div></div> <div class="hide" data-v-4698c43e><header class="navbar" data-v-4698c43e><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">不为无益之事，安能悦有涯之生.</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/guide/" class="nav-link"><i class="iconfont reco-eye"></i>
  史与哲与思
</a></div><div class="nav-item"><a href="http://zhixi.online/" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont undefined"></i>
  ChatGPT
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-api"></i>
      技术分享
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>后端开发</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/技术文章/后端开发/java.html" class="nav-link"><i class="iconfont undefined"></i>
  java
</a></li><li class="dropdown-subitem"><a href="/技术文章/后端开发/C.html" class="nav-link"><i class="iconfont undefined"></i>
  C#
</a></li><li class="dropdown-subitem"><a href="/技术文章/后端开发/python.html" class="nav-link"><i class="iconfont undefined"></i>
  python
</a></li></ul></li><li class="dropdown-item"><h4>前端</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/技术文章/vue/vue02.html" class="nav-link"><i class="iconfont undefined"></i>
  vue2
</a></li><li class="dropdown-subitem"><a href="/技术文章/vue/vue03.html" class="nav-link"><i class="iconfont undefined"></i>
  vue3
</a></li><li class="dropdown-subitem"><a href="/技术文章/vue/javascript.html" class="nav-link"><i class="iconfont undefined"></i>
  源生
</a></li></ul></li><li class="dropdown-item"><h4>BUG梳理</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/BUG梳理/bug.html" class="nav-link"><i class="iconfont undefined"></i>
  BUG梳理
</a></li></ul></li><li class="dropdown-item"><h4>工具分享</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/工具分享/tool.html" class="nav-link"><i class="iconfont undefined"></i>
  原创
</a></li><li class="dropdown-subitem"><a href="/工具分享/toolCope.html" class="nav-link"><i class="iconfont undefined"></i>
  转载
</a></li></ul></li><li class="dropdown-item"><h4>面试八股</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/面试八股/interview.html" class="nav-link"><i class="iconfont undefined"></i>
  面试八股
</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-faq"></i>
      随笔
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/树洞随笔/life.html" class="nav-link"><i class="iconfont undefined"></i>
  树洞随笔
</a></li><li class="dropdown-item"><!----> <a href="/树洞随笔/Engage with the world.html" class="nav-link"><i class="iconfont undefined"></i>
  Engage with the world
</a></li><li class="dropdown-item"><!----> <a href="/树洞随笔/Nietzsche.html" class="nav-link"><i class="iconfont undefined"></i>
  尼采与虚无
</a></li><li class="dropdown-item"><!----> <a href="/树洞随笔/To Be Human.html" class="nav-link"><i class="iconfont undefined"></i>
  生而为人
</a></li><li class="dropdown-item"><!----> <a href="/树洞随笔/xiaobinwuyu.html" class="nav-link"><i class="iconfont undefined"></i>
  小兵物语
</a></li><li class="dropdown-item"><!----> <a href="/树洞随笔/给自己的信.html" class="nav-link"><i class="iconfont undefined"></i>
  给自己的信
</a></li><li class="dropdown-item"><!----> <a href="/树洞随笔/剑客律师.html" class="nav-link"><i class="iconfont undefined"></i>
  剑客律师
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-blog"></i>
      博客
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/kfpvdt/" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-blog"></i>
  github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://space.bilibili.com/457171051?spm_id_from=333.1007.0.0" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-bilibili"></i>
  B站
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://www.52pojie.cn/home.php?mod=space&amp;uid=799153" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-blog"></i>
  吾爱破解
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div><div class="nav-item"><a href="/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  时间轴
</a></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-4698c43e></div> <aside class="sidebar" data-v-4698c43e><div class="personal-info-wrapper" data-v-6c8ffc9c><img src="/avatar.png" alt="author-avatar" class="personal-img" data-v-6c8ffc9c> <h3 class="name" data-v-6c8ffc9c>
    跖蹊
  </h3> <div class="num" data-v-6c8ffc9c><div data-v-6c8ffc9c><h3 data-v-6c8ffc9c>42</h3> <h6 data-v-6c8ffc9c>文章</h6></div> <div data-v-6c8ffc9c><h3 data-v-6c8ffc9c>18</h3> <h6 data-v-6c8ffc9c>标签</h6></div></div> <hr data-v-6c8ffc9c></div> <nav class="nav-links"><div class="nav-item"><a href="/guide/" class="nav-link"><i class="iconfont reco-eye"></i>
  史与哲与思
</a></div><div class="nav-item"><a href="http://zhixi.online/" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont undefined"></i>
  ChatGPT
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-api"></i>
      技术分享
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>后端开发</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/技术文章/后端开发/java.html" class="nav-link"><i class="iconfont undefined"></i>
  java
</a></li><li class="dropdown-subitem"><a href="/技术文章/后端开发/C.html" class="nav-link"><i class="iconfont undefined"></i>
  C#
</a></li><li class="dropdown-subitem"><a href="/技术文章/后端开发/python.html" class="nav-link"><i class="iconfont undefined"></i>
  python
</a></li></ul></li><li class="dropdown-item"><h4>前端</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/技术文章/vue/vue02.html" class="nav-link"><i class="iconfont undefined"></i>
  vue2
</a></li><li class="dropdown-subitem"><a href="/技术文章/vue/vue03.html" class="nav-link"><i class="iconfont undefined"></i>
  vue3
</a></li><li class="dropdown-subitem"><a href="/技术文章/vue/javascript.html" class="nav-link"><i class="iconfont undefined"></i>
  源生
</a></li></ul></li><li class="dropdown-item"><h4>BUG梳理</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/BUG梳理/bug.html" class="nav-link"><i class="iconfont undefined"></i>
  BUG梳理
</a></li></ul></li><li class="dropdown-item"><h4>工具分享</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/工具分享/tool.html" class="nav-link"><i class="iconfont undefined"></i>
  原创
</a></li><li class="dropdown-subitem"><a href="/工具分享/toolCope.html" class="nav-link"><i class="iconfont undefined"></i>
  转载
</a></li></ul></li><li class="dropdown-item"><h4>面试八股</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/面试八股/interview.html" class="nav-link"><i class="iconfont undefined"></i>
  面试八股
</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-faq"></i>
      随笔
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/树洞随笔/life.html" class="nav-link"><i class="iconfont undefined"></i>
  树洞随笔
</a></li><li class="dropdown-item"><!----> <a href="/树洞随笔/Engage with the world.html" class="nav-link"><i class="iconfont undefined"></i>
  Engage with the world
</a></li><li class="dropdown-item"><!----> <a href="/树洞随笔/Nietzsche.html" class="nav-link"><i class="iconfont undefined"></i>
  尼采与虚无
</a></li><li class="dropdown-item"><!----> <a href="/树洞随笔/To Be Human.html" class="nav-link"><i class="iconfont undefined"></i>
  生而为人
</a></li><li class="dropdown-item"><!----> <a href="/树洞随笔/xiaobinwuyu.html" class="nav-link"><i class="iconfont undefined"></i>
  小兵物语
</a></li><li class="dropdown-item"><!----> <a href="/树洞随笔/给自己的信.html" class="nav-link"><i class="iconfont undefined"></i>
  给自己的信
</a></li><li class="dropdown-item"><!----> <a href="/树洞随笔/剑客律师.html" class="nav-link"><i class="iconfont undefined"></i>
  剑客律师
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-blog"></i>
      博客
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/kfpvdt/" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-blog"></i>
  github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://space.bilibili.com/457171051?spm_id_from=333.1007.0.0" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-bilibili"></i>
  B站
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://www.52pojie.cn/home.php?mod=space&amp;uid=799153" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-blog"></i>
  吾爱破解
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div><div class="nav-item"><a href="/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  时间轴
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>面试八股</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/interview.html#_1-执行上下文-作用域-闭包" class="sidebar-link">1.执行上下文/作用域/闭包</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/interview.html#_1-什么是执行上下文" class="sidebar-link">1.什么是执行上下文?</a></li><li class="sidebar-sub-header"><a href="/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/interview.html#_2-作用域-scope" class="sidebar-link">2.作用域(Scope)</a></li><li class="sidebar-sub-header"><a href="/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/interview.html#_3-闭包" class="sidebar-link">3.闭包</a></li></ul></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/interview.html#_2-this-call-apply-bind" class="sidebar-link">2.this/call/apply/bind</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/interview.html#_1-this的指向" class="sidebar-link">1.this的指向</a></li><li class="sidebar-sub-header"><a href="/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/interview.html#_2-call" class="sidebar-link">2.call</a></li><li class="sidebar-sub-header"><a href="/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/interview.html#_3-apply" class="sidebar-link">3.apply</a></li><li class="sidebar-sub-header"><a href="/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/interview.html#_4-bind" class="sidebar-link">4.bind</a></li></ul></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/interview.html#_3-原型-继承" class="sidebar-link">3.原型/继承</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/interview.html#_1-原型" class="sidebar-link">1.原型</a></li><li class="sidebar-sub-header"><a href="/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/interview.html#_2-继承" class="sidebar-link">2.继承</a></li></ul></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/interview.html#_4-promise" class="sidebar-link">4.promise</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/interview.html#_1-什么是promise-它用来解决什么问题" class="sidebar-link">1. 什么是promise?它用来解决什么问题?</a></li><li class="sidebar-sub-header"><a href="/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/interview.html#_2-promise用法" class="sidebar-link">2. promise用法</a></li><li class="sidebar-sub-header"><a href="/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/interview.html#_3-async-await" class="sidebar-link">3. async/await</a></li></ul></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/interview.html#_5-深浅拷贝" class="sidebar-link">5.深浅拷贝</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/interview.html#什么是浅拷贝" class="sidebar-link">什么是浅拷贝?</a></li><li class="sidebar-sub-header"><a href="/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/interview.html#什么是深拷贝" class="sidebar-link">什么是深拷贝？</a></li><li class="sidebar-sub-header"><a href="/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/interview.html#javascript中的拷贝方法" class="sidebar-link">JavaScript中的拷贝方法</a></li><li class="sidebar-sub-header"><a href="/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/interview.html#总结" class="sidebar-link">总结</a></li></ul></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/interview.html#_6-event-loop-事件循环" class="sidebar-link">6.event loop(事件循环)</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/interview.html#什么是事件循环" class="sidebar-link">什么是事件循环?</a></li><li class="sidebar-sub-header"><a href="/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/interview.html#事件循环的一些举例" class="sidebar-link">事件循环的一些举例</a></li><li class="sidebar-sub-header"><a href="/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/interview.html#宏任务-macro-task-和微任务-micro-task" class="sidebar-link">宏任务(macro-task)和微任务(micro-task)</a></li><li class="sidebar-sub-header"><a href="/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/interview.html#如何实现一个事件的订阅与发布" class="sidebar-link">?如何实现一个事件的订阅与发布</a></li></ul></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/interview.html#_7-函数式编程" class="sidebar-link">7.函数式编程</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/interview.html#什么是函数式编程" class="sidebar-link">什么是函数式编程？</a></li><li class="sidebar-sub-header"><a href="/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/interview.html#函数式编程的优劣势" class="sidebar-link">函数式编程的优劣势</a></li><li class="sidebar-sub-header"><a href="/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/interview.html#函数柯里化-curry" class="sidebar-link">函数柯里化(curry)</a></li></ul></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/interview.html#_8-service-worker-pwa" class="sidebar-link">8.Service Worker/PWA</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/interview.html#_9-web-worker" class="sidebar-link">9.Web Worker</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/interview.html#_10-es6知识" class="sidebar-link">10.ES6知识</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/interview.html#_1-position" class="sidebar-link">1.position</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/interview.html#什么是position" class="sidebar-link">什么是position?</a></li></ul></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/interview.html#_2-行内元素-块级元素" class="sidebar-link">2.行内元素/块级元素</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/interview.html#什么是行内元素" class="sidebar-link">什么是行内元素？</a></li><li class="sidebar-sub-header"><a href="/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/interview.html#什么是块级元素" class="sidebar-link">什么是块级元素</a></li><li class="sidebar-sub-header"><a href="/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/interview.html#行内元素与块级元素的区别" class="sidebar-link">行内元素与块级元素的区别</a></li><li class="sidebar-sub-header"><a href="/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/interview.html#bfc-块格式化上下文" class="sidebar-link">BFC(块格式化上下文)</a></li></ul></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/interview.html#_3-flex布局" class="sidebar-link">3.flex布局</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/interview.html#什么是flex布局" class="sidebar-link">什么是flex布局?</a></li><li class="sidebar-sub-header"><a href="/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/interview.html#如何用flex实现九宫格布局" class="sidebar-link">如何用flex实现九宫格布局</a></li><li class="sidebar-sub-header"><a href="/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/interview.html#flex-1指的是什么-flex属性默认值是什么" class="sidebar-link">flex:1指的是什么？flex属性默认值是什么</a></li><li class="sidebar-sub-header"><a href="/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/interview.html#介绍一下flex-shrink和flex-basis属性" class="sidebar-link">介绍一下flex-shrink和flex-basis属性</a></li></ul></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/interview.html#_4-1px问题" class="sidebar-link">4.1px问题</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/interview.html#_5-重绘与回流" class="sidebar-link">5.重绘与回流</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/interview.html#_1-回流-reflow" class="sidebar-link">1.回流 (Reflow)</a></li><li class="sidebar-sub-header"><a href="/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/interview.html#_3-性能影响" class="sidebar-link">3.性能影响</a></li><li class="sidebar-sub-header"><a href="/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/interview.html#_4-如何避免" class="sidebar-link">4.如何避免</a></li></ul></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/interview.html#_6-居中布局" class="sidebar-link">6.居中布局</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/interview.html#_7-层叠上下文" class="sidebar-link">7.层叠上下文</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/interview.html#_1-什么是层叠上下文" class="sidebar-link">1.什么是层叠上下文</a></li><li class="sidebar-sub-header"><a href="/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/interview.html#_2-什么是层叠等级" class="sidebar-link">2.什么是层叠等级</a></li><li class="sidebar-sub-header"><a href="/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/interview.html#_3-如何产生-层叠上下文" class="sidebar-link">3.如何产生&quot;层叠上下文&quot;</a></li></ul></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/interview.html#_8-sass-less" class="sidebar-link">8.sass/less</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/interview.html#_3-vue" class="sidebar-link">3.Vue</a></li></ul></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/interview.html#_1-mvvm" class="sidebar-link">1.MVVM</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/interview.html#_1-什么是mvvm" class="sidebar-link">1.什么是MVVM?</a></li></ul></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/interview.html#_2-viewmodel有什么好处" class="sidebar-link">2.ViewModel有什么好处?</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/interview.html#_2-生命周期" class="sidebar-link">2.生命周期</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/interview.html#_1-介绍一下vue生命周期" class="sidebar-link">1.介绍一下Vue生命周期</a></li><li class="sidebar-sub-header"><a href="/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/interview.html#_2-nexttick是如何实现的" class="sidebar-link">2.nextTick是如何实现的</a></li><li class="sidebar-sub-header"><a href="/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/interview.html#_3-父子组件挂载时-生命周期的顺序是怎么样的" class="sidebar-link">3.父子组件挂载时,生命周期的顺序是怎么样的</a></li></ul></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/interview.html#_3-数据绑定" class="sidebar-link">3.数据绑定</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/interview.html#_1-vue的双向绑定如何实现" class="sidebar-link">1.Vue的双向绑定如何实现</a></li><li class="sidebar-sub-header"><a href="/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/interview.html#_2-vue如何监听数组或对象的改变" class="sidebar-link">2.Vue如何监听数组或对象的改变</a></li><li class="sidebar-sub-header"><a href="/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/interview.html#_3-defineproperty和proxy的区别" class="sidebar-link">3.defineProperty和proxy的区别</a></li><li class="sidebar-sub-header"><a href="/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/interview.html#_4-vue中的数据为什么频繁变化但只会更新一次" class="sidebar-link">4.Vue中的数据为什么频繁变化但只会更新一次</a></li></ul></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/interview.html#_4-状态管理" class="sidebar-link">4.状态管理</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/interview.html#_1-vuex是什么" class="sidebar-link">1.vuex是什么</a></li><li class="sidebar-sub-header"><a href="/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/interview.html#_2-什么时候使用vuex" class="sidebar-link">2.什么时候使用vuex?</a></li><li class="sidebar-sub-header"><a href="/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/interview.html#_3-vuex的工作原理" class="sidebar-link">3.vuex的工作原理</a></li><li class="sidebar-sub-header"><a href="/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/interview.html#_4-vuex中4个map方法的使用" class="sidebar-link">4. vuex中4个map方法的使用</a></li><li class="sidebar-sub-header"><a href="/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/interview.html#_5-vuex的基本使用" class="sidebar-link">5.vuex的基本使用</a></li><li class="sidebar-sub-header"><a href="/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/interview.html#_6-vuex中的数据在页面刷新后消失怎么办" class="sidebar-link">6.vuex中的数据在页面刷新后消失怎么办?</a></li></ul></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/interview.html#_5-组件通信" class="sidebar-link">5.组件通信</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/interview.html#_1-vue组件间通信有哪几种方式" class="sidebar-link">1. vue组件间通信有哪几种方式?</a></li><li class="sidebar-sub-header"><a href="/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/interview.html#_7-vuex" class="sidebar-link">7.vuex</a></li></ul></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/interview.html#_6-virtual-dom" class="sidebar-link">6.Virtual DOM</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/interview.html#_1-虚拟dom是什么" class="sidebar-link">1.虚拟dom是什么</a></li><li class="sidebar-sub-header"><a href="/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/interview.html#_2-为什么需要虚拟dom" class="sidebar-link">2.为什么需要虚拟dom</a></li><li class="sidebar-sub-header"><a href="/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/interview.html#_3-vue的虚拟dom解决了什么问题" class="sidebar-link">3.vue的虚拟dom解决了什么问题</a></li><li class="sidebar-sub-header"><a href="/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/interview.html#_4-虚拟dom的实现原理" class="sidebar-link">4.虚拟DOM的实现原理</a></li></ul></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/interview.html#_7-diff" class="sidebar-link">7.diff</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/interview.html#_1-实现diff的思路" class="sidebar-link">1.实现diff的思路</a></li></ul></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/interview.html#_8-vue-computed-watch" class="sidebar-link">8.Vue computed/watch</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/interview.html#_1-computed-和-watch-的区别和运用的场景" class="sidebar-link">1.computed 和 watch 的区别和运用的场景？</a></li></ul></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/interview.html#_9-vue和react有什么不同" class="sidebar-link">9.Vue和React有什么不同</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/interview.html#_4-网络" class="sidebar-link">4.网络</a></li></ul></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/interview.html#_1-http" class="sidebar-link">1.HTTP</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/interview.html#_2-dns" class="sidebar-link">2.DNS</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/interview.html#_3-tcp" class="sidebar-link">3.TCP</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/interview.html#_4-https" class="sidebar-link">4.HTTPS</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/interview.html#_5-cdn" class="sidebar-link">5.CDN</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/interview.html#_6-从输入url到页面展示发生了什么" class="sidebar-link">6.从输入url到页面展示发生了什么</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/interview.html#dns解析" class="sidebar-link">DNS解析</a></li><li class="sidebar-sub-header"><a href="/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/interview.html#tcp连接-tcp三次握手" class="sidebar-link">TCP连接：TCP三次握手</a></li><li class="sidebar-sub-header"><a href="/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/interview.html#浏览器向web服务器发送http请求" class="sidebar-link">浏览器向web服务器发送HTTP请求</a></li><li class="sidebar-sub-header"><a href="/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/interview.html#服务器处理请求并返回http报文" class="sidebar-link">服务器处理请求并返回HTTP报文</a></li><li class="sidebar-sub-header"><a href="/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/interview.html#浏览器解析渲染页面" class="sidebar-link">浏览器解析渲染页面</a></li><li class="sidebar-sub-header"><a href="/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/interview.html#tcp四次挥手。" class="sidebar-link">TCP四次挥手。</a></li></ul></li></ul></section></li></ul> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-6cbeab0a data-v-4698c43e><h3 class="title" style="display:none;" data-v-6cbeab0a data-v-6cbeab0a> 面试八股</h3> <!----> <label id="box" class="inputBox" style="display:none;" data-v-6cbeab0a data-v-6cbeab0a><input type="password" value="" data-v-6cbeab0a> <span data-v-6cbeab0a>Konck! Knock!</span> <button data-v-6cbeab0a>OK</button></label> <div class="footer" style="display:none;" data-v-6cbeab0a data-v-6cbeab0a><span data-v-6cbeab0a><i class="iconfont reco-theme" data-v-6cbeab0a></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-6cbeab0a>vuePress-theme-reco</a></span> <span data-v-6cbeab0a><i class="iconfont reco-copyright" data-v-6cbeab0a></i> <a data-v-6cbeab0a><span data-v-6cbeab0a>跖蹊</span>
            
          <span data-v-6cbeab0a>2022 - </span>
          2023
        </a></span></div></div> <div data-v-4698c43e><main class="page"><!----> <div class="page-title" style="display:none;"><h1>面试八股</h1> <hr> <div data-v-484a899e><i class="iconfont reco-account" data-v-484a899e><span data-v-484a899e>跖蹊</span></i> <i class="iconfont reco-date" data-v-484a899e><span data-v-484a899e>2023-04-25 17:44:15</span></i> <!----> <i class="iconfont reco-tag tags" data-v-484a899e><span class="tag-item" data-v-484a899e>
      面试八股
    </span></i></div></div> <div class="theme-reco-content content__default" style="display:none;"><div class="custom-block warning"><p class="custom-block-title">面试八股</p> <p>JavaScript+js+vue</p></div> <p><strong>这篇博客是对前端面试所必须掌握的知识点的总结,并且这篇博客正在持续更新中...</strong></p> <h1 id="_1-javascript-基础"><a href="#_1-javascript-基础" class="header-anchor">#</a> 1.JavaScript 基础</h1> <p><img src="https://img-blog.csdnimg.cn/img_convert/1a9b67a1326d001eebd4838143a9d146.png" alt=""></p> <h2 id="_1-执行上下文-作用域-闭包"><a href="#_1-执行上下文-作用域-闭包" class="header-anchor">#</a> <a name="1_11"></a>  1.执行上下文/作用域/闭包</h2> <h3 id="_1-什么是执行上下文"><a href="#_1-什么是执行上下文" class="header-anchor">#</a> 1.什么是执行上下文?</h3> <p>执行上下文是评估和执行JavaScript代码环境的抽象概念。每当JavaScript代码在运行时，他都是在执行上下文中运行。</p> <p><strong>执行上下文的类型</strong></p> <p>JavaScript共有 <strong>三种</strong>执行上下文类型</p> <ul><li><strong>全局执行上下文</strong> <ul><li>这是基础的上下文,任何不在函数内部的代码都在全局上下文中.他会执行两件事:创建一个全局的window对象(浏览器环境的情况下),并且设置this的值等于这个全局对象。一个程序中只会有一个全局执行上下文</li></ul></li> <li><strong>函数执行上下文</strong> <ul><li>每当函数被调用时，都会为该函数创建一个新的执行上下文。每个函数都有他自己的执行上下文，只不过是在函数被调用时才被创建的。函数上下文可以有任意多个。每当一个新的执行上下文被创建，他会按定义的瞬狙执行一系列步骤</li></ul></li> <li><strong>Eval函数执行上下文</strong> <ul><li>执行在 <code>eval</code> 函数内部的代码也会有它属于自己的执行上下文</li></ul></li></ul> <p><strong>执行上下文栈</strong></p> <p>执行栈，也就是在其它编程语言中所说的&quot;调用栈&quot;，是一种拥有 LIFO（后进先出）数据结构的栈，被用来存储代码运行时创建的所有执行上下文。</p> <p>当JavaScript引擎第一次遇到你的脚本时，他会创建一个全局的执行上下文并且压入当前执行栈。 <strong>每当引擎遇到一个函数调用，他会为该函数创建一个新的执行上下文并压入栈的顶部.</strong></p> <p>引擎会执行那些执行上下文位于栈顶的函数. <strong>每当函数执行结束之后，最上层的执行上下文从栈中弹出</strong>，控制流程到达当前栈中的下一个上下文</p> <p><strong>一旦所有代码执行完毕，JavaScript引擎从当前栈中移除全局执行上下文</strong></p> <p><img src="https://img-blog.csdnimg.cn/img_convert/a2dc541dd56cf336f80dbbdbb6074bb9.png" alt=""></p> <p><strong>怎么创建执行上下文?</strong></p> <p>创建执行上下文有两个阶段:</p> <ol><li><strong>创建阶段</strong></li> <li><strong>执行阶段</strong></li></ol> <p><strong>创建阶段</strong></p> <p>在JavaScript代码执行前，执行上下文将经历创建阶段。在创建阶段将会发生三件事:</p> <ol><li><strong>this</strong>值的绑定</li> <li>创建 <strong>词法环境</strong></li> <li>创建 <strong>变量环境</strong></li></ol> <p>所以执行上下文在概念上表示如下：</p> <div class="language- extra-class"><pre class="language-text"><code>ExecutionContext = {
  ThisBinding = &lt;this value&gt;,
  LexicalEnvironment = { ... },
  VariableEnvironment = { ... },
}
&lt;/this&gt;
</code></pre></div><p><strong>This绑定:</strong></p> <p>在全局执行上下文中, <code>this</code>的值指向全局对象(在浏览器中,全局对象为 <code>window</code>')</p> <p>在函数执行上下文中,this的值取决于该函数是如何被调用的.如果他被一个引用类型对象调用,那么this会被设置成那个对象,否则 <code>this</code>的值被设置成全局对象或者 <code>undefined</code>(严格模式)</p> <div class="language-java extra-class"><pre class="language-java"><code>let foo <span class="token operator">=</span> <span class="token punctuation">{</span>
  baz<span class="token operator">:</span> <span class="token function">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

foo<span class="token punctuation">.</span><span class="token function">baz</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

let bar <span class="token operator">=</span> foo<span class="token punctuation">.</span>baz<span class="token punctuation">;</span>

<span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div><p><strong>词法环境</strong></p> <p><a href="https://link.juejin.cn/?target=http%3A%2F%2Fecma-international.org%2Fecma-262%2F6.0%2F" target="_blank" rel="noopener noreferrer">官方的 ES6<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 文档把词法环境定义为</p> <blockquote><p><strong>词法环境</strong>是一种规范类型，基于 ECMAScript 代码的词法嵌套结构来定义 <strong>标识符</strong>和具体变量和函数的关联。一个词法环境由环境记录器和一个可能的引用 <strong>外部</strong>词法环境的空值组成。</p></blockquote> <p>词法环境是一种持有 <strong>变量符-变量映射</strong>的结构(标识符指的是变量/函数的名字,而变量是对实际对象或原始数据的引用)</p> <p>在词法环境的内部有两个组件:1. <strong>环境记录器</strong>和2.一个 <strong>外部环境的引用</strong></p> <ol><li><p><strong>环境记录器</strong>是存储变量和函数声明的实际位置</p></li> <li><p><strong>外部环境的引用</strong>意味着它可以访问其父级词法环境(作用域)</p></li></ol> <p><strong>词法环境</strong>有两种类型: <strong>全局环境</strong>和 <strong>函数环境</strong></p> <ul><li><strong>全局环境</strong>(在全局执行上下文中)是没有外部环境引用的词法环境,全局环境的外部环境引用是 <strong>null</strong>， 它拥有创建的Object/Array等,在环境记录器内的原型函数(关联全局对象,比如window对象)还有任何用户定义的全局变量,并且 <code>this</code>的值指向全局对象</li> <li>在 <strong>函数环境</strong>中，函数内部用户定义的变量存储在 <strong>环境记录器</strong>中。并且引用的外部环境可能是全局环境，或者任何包含此内部函数的外部函数。</li></ul> <p>环境记录器也有两种类型:</p> <ol><li><strong>声明式环境记录器</strong>，用来存储变量、函数和参数</li> <li><strong>对象环境记录器</strong>,用来定义出现在 <strong>全局上下文</strong>中的变量和函数关系</li></ol> <p>由上不难得知</p> <ul><li>在 <strong>全局环境</strong>中,环境记录器是对象环境记录器</li> <li>在 <strong>函数环境</strong>中,环境记录器是声明式环境记录器</li></ul> <p><strong>注意 :</strong> 对于 <strong>函数环境</strong>， <strong>声明式环境记录器</strong>还包含了一个传递给函数的 <code>arguments</code> 对象（此对象存储索引和参数的映射）和传递给函数的参数的 <strong>length</strong>。</p> <p>抽象地讲，词法环境在伪代码中看起来像这样：</p> <div class="language- extra-class"><pre class="language-text"><code>GlobalExectionContext = {
  LexicalEnvironment: {
    EnvironmentRecord: {
      Type: &quot;Object&quot;,
      // &amp;#x5728;&amp;#x8FD9;&amp;#x91CC;&amp;#x7ED1;&amp;#x5B9A;&amp;#x6807;&amp;#x8BC6;&amp;#x7B26;
    }
    outer: &lt;null&gt;
  }
}

FunctionExectionContext = {
  LexicalEnvironment: {
    EnvironmentRecord: {
      Type: &quot;Declarative&quot;,
      // &amp;#x5728;&amp;#x8FD9;&amp;#x91CC;&amp;#x7ED1;&amp;#x5B9A;&amp;#x6807;&amp;#x8BC6;&amp;#x7B26;
    }
    outer: &lt;global or outer function environment reference&gt;
  }
}
&lt;/global&gt;&lt;/null&gt;
</code></pre></div><p><strong>变量环境</strong></p> <p>变量环境其实也是一个 <strong>词法环境</strong>,其环境记录器中持有变量声明语句在执行上下文中创建的绑定关系</p> <p>变量环境有着词法环境的所有属性</p> <p>在ES6中,词法环境组件和变量环境的一个不同就是前者被用来存储函数声明和变量(<code>let</code>和 <code>const</code>)绑定,而后者只用来存储 <code>var</code>变量绑定</p> <p>我们看点样例代码来理解上面的概念：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> b <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> c<span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">multiply</span><span class="token punctuation">(</span><span class="token parameter">e<span class="token punctuation">,</span> f</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token keyword">var</span> g <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>
 <span class="token keyword">return</span> e <span class="token operator">*</span> f <span class="token operator">*</span> g<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

c <span class="token operator">=</span> <span class="token function">multiply</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div><p>执行上下文看起来像这样：</p> <div class="language-js extra-class"><pre class="language-js"><code>GlobalExectionContext <span class="token operator">=</span> <span class="token punctuation">{</span>

  <span class="token literal-property property">ThisBinding</span><span class="token operator">:</span> <span class="token operator">&lt;</span>Global Object<span class="token operator">&gt;</span><span class="token punctuation">,</span>

  <span class="token literal-property property">LexicalEnvironment</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">EnvironmentRecord</span><span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token literal-property property">Type</span><span class="token operator">:</span> <span class="token string">&quot;Object&quot;</span><span class="token punctuation">,</span>

      <span class="token literal-property property">a</span><span class="token operator">:</span> <span class="token operator">&lt;</span> uninitialized <span class="token operator">&gt;</span><span class="token punctuation">,</span>
      <span class="token literal-property property">b</span><span class="token operator">:</span> <span class="token operator">&lt;</span> uninitialized <span class="token operator">&gt;</span><span class="token punctuation">,</span>
      <span class="token literal-property property">multiply</span><span class="token operator">:</span> <span class="token operator">&lt;</span> func <span class="token operator">&gt;</span>
    <span class="token punctuation">}</span>
    <span class="token literal-property property">outer</span><span class="token operator">:</span> <span class="token operator">&lt;</span><span class="token keyword">null</span><span class="token operator">&gt;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>

  <span class="token literal-property property">VariableEnvironment</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">EnvironmentRecord</span><span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token literal-property property">Type</span><span class="token operator">:</span> <span class="token string">&quot;Object&quot;</span><span class="token punctuation">,</span>

      <span class="token literal-property property">c</span><span class="token operator">:</span> <span class="token keyword">undefined</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span>
    <span class="token literal-property property">outer</span><span class="token operator">:</span> <span class="token operator">&lt;</span><span class="token keyword">null</span><span class="token operator">&gt;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

FunctionExectionContext <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">ThisBinding</span><span class="token operator">:</span> <span class="token operator">&lt;</span>Global Object<span class="token operator">&gt;</span><span class="token punctuation">,</span>

  <span class="token literal-property property">LexicalEnvironment</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">EnvironmentRecord</span><span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token literal-property property">Type</span><span class="token operator">:</span> <span class="token string">&quot;Declarative&quot;</span><span class="token punctuation">,</span>

      <span class="token literal-property property">Arguments</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token operator">:</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token operator">:</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token literal-property property">length</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token literal-property property">outer</span><span class="token operator">:</span> <span class="token operator">&lt;</span>GlobalLexicalEnvironment<span class="token operator">&gt;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>

<span class="token literal-property property">VariableEnvironment</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">EnvironmentRecord</span><span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token literal-property property">Type</span><span class="token operator">:</span> <span class="token string">&quot;Declarative&quot;</span><span class="token punctuation">,</span>

      <span class="token literal-property property">g</span><span class="token operator">:</span> <span class="token keyword">undefined</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token literal-property property">outer</span><span class="token operator">:</span> <span class="token operator">&lt;</span>GlobalLexicalEnvironment<span class="token operator">&gt;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>可能你已经注意到 <code>let</code> 和 <code>const</code> 定义的变量并没有关联任何值，但 <code>var</code> 定义的变量被设成了 <code>undefined</code>。</p> <p>这是因为在创建阶段时，引擎检查代码找出变量和函数声明，虽然函数声明完全存储在环境中，但是变量最初设置为 <code>undefined</code>（ <code>var</code> 情况下），或者未初始化（ <code>let</code> 和 <code>const</code> 情况下）。</p> <p>这就是为什么你可以在声明之前访问 <code>var</code> 定义的变量（虽然是 <code>undefined</code>），但是在声明之前访问 <code>let</code> 和 <code>const</code> 的变量会得到一个引用错误。</p> <p>这就是我们说的 <strong>变量声明提升</strong>。</p> <p><strong>执行阶段</strong></p> <p><strong>在此阶段完成对所有存储的变量的分配,最后执行代码.</strong></p> <p><strong>注意:</strong> 在执行阶段,如果JavaScript引擎不能再源码中声明的实际位置找到 <code>let</code>变量的值，那么他就会被赋值为 <code>undefined</code></p> <h3 id="_2-作用域-scope"><a href="#_2-作用域-scope" class="header-anchor">#</a> 2.作用域(Scope)</h3> <p><strong>什么是作用域?</strong></p> <p><strong>作用域是指程序源代码中定义变量的区域。</strong></p> <p>作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。</p> <p>JavaScript 采用 <strong>词法作用域</strong>(lexical scoping)，也就是静态作用域。</p> <p>我们可以这样理解： <strong>作用域就是一个独立的地盘，让变量不会外泄、暴露出去</strong>。也就是说 <strong>作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突。</strong></p> <p>ES6之前,JavaScript只有 <strong>全局作用域</strong>和 <strong>函数作用域</strong>,ES6之后，新增了 <strong>块级作用域</strong>，可以通过 <code>let</code>和 <code>const</code>来创建</p> <p><strong>全局作用域和函数作用域</strong></p> <p>**在代码中任何地方都能访问到的对象拥有全局作用域,**以下几种情况拥有全局作用域:</p> <ul><li>最外层函数和在最外层函数外定义的变量拥有全局作用域</li> <li>所有未定义直接赋值的变量默认为全局变量，拥有全局作用域</li> <li>所有window对象的属性拥有全局作用域</li></ul> <p>全局作用域的 <strong>弊端</strong>:容易引发命名冲突，污染全局命名空间</p> <p><strong>函数作用域</strong></p> <p><strong>在函数内部声明的变量</strong>拥有函数作用域,一般只能在固定的代码片段内可以访问到.</p> <p>作用域是分层的,内层作用域可以访问外层作用域的变量,反之则不行</p> <p><img src="https://img-blog.csdnimg.cn/img_convert/0d4d97dfee1a6bc262685437011cc79c.png" alt=""></p> <p>值得注意的是： <strong>块语句（大括号&quot;｛｝&quot;中间的语句），如 if 和 switch 条件语句或 for 和 while 循环语句，不像函数，它们不会创建一个新的作用域</strong>。在块语句中定义的变量将保留在它们已经存在的作用域中。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token keyword">var</span> name <span class="token operator">=</span> <span class="token string">'Hammad'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p><strong>块级作用域</strong></p> <p>块级作用域可以通过 <code>let</code>和 <code>const</code>声明,所声明的变量在指定块作用域·之外无法被访问。</p> <p>块级作用域在如下情况被创建:</p> <ol><li>在一个函数内部</li> <li>在一个代码块内部(' <strong>{}</strong>')</li></ol> <p>块级作用域有以下几个特点:</p> <ul><li>声明变量不会提升的代码块顶部</li> <li>禁止重复声明</li></ul> <p><strong>作用域链</strong></p> <p>在JavaScript中,函数、块、模块都可以形成作用域,他们之间可以相互嵌套、作用域之间会形成引用关系，这条链叫做作用域链</p> <p><strong>作用域链的创建和变化</strong></p> <p><strong>函数创建时:</strong></p> <p>JavaScript中使用的是词法作用域, <strong>函数的作用域在函数定义的时候就已经决定了</strong></p> <p>函数有一个内部属性[[scope]]，当函数创建的时候,就会保存所有父变量对象到其中,可以理解为[[scope]]就是所有父变量对象的层级链,但是注意:[[scope]]并不代表完整的作用域链</p> <p>举个例子：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token operator">...</span>

    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>函数创建时，各自的[[scope]]为：</p> <div class="language-js extra-class"><pre class="language-js"><code>foo<span class="token punctuation">.</span><span class="token punctuation">[</span><span class="token punctuation">[</span>scope<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>
  globalContext<span class="token punctuation">.</span><span class="token constant">VO</span>
<span class="token punctuation">]</span><span class="token punctuation">;</span>

bar<span class="token punctuation">.</span><span class="token punctuation">[</span><span class="token punctuation">[</span>scope<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>
    fooContext<span class="token punctuation">.</span><span class="token constant">AO</span><span class="token punctuation">,</span>
    globalContext<span class="token punctuation">.</span><span class="token constant">VO</span>
<span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre></div><p><strong>函数被激活时:</strong></p> <p>当函数被激活时,进入函数上下文,创建VO/AO后就会将活动对象添加到作用域的前端</p> <p>这时候执行上下文的作用域链,我们命名为Scope</p> <div class="language-js extra-class"><pre class="language-js"><code>Scope <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token constant">AO</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span>Scope<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>至此, <strong>作用域链创建完毕</strong></p> <h3 id="_3-闭包"><a href="#_3-闭包" class="header-anchor">#</a> 3.闭包</h3> <p><strong>什么是闭包?</strong></p> <p>闭包就是同时含有对函数对象以及作用域对象引用的对象,实际上所有JavaScript对象都是闭包.</p> <p><strong>本质</strong>:在一个函数内部创建另一个函数</p> <p><strong>只要存在函数嵌套,并且内部函数调用了外部函数的属性,就产生了闭包.</strong></p> <p>闭包的特性:</p> <ul><li>函数嵌套函数</li> <li>函数内部引用函数外部的参数和变量</li> <li>参数和变量不会被垃圾回收机制回收</li></ul> <p><strong>闭包是什么时候被创建的？</strong></p> <p>因为所有JavaScript对象都是闭包,所以当你定义一个函数时.就产生了闭包</p> <p><strong>闭包是什么时候被销毁的?</strong></p> <p>当他不被任何其他的对象引用的时候，闭包就被销毁</p> <p><strong>闭包的好处</strong>:</p> <ul><li>保护函数内的变量安全,实现封装,防止变量流入其他环境发生命名冲突</li> <li>在内存中维持一个变量，延长变量的生命周期</li> <li>匿名自执行函数可以减少内存消耗</li></ul> <p><strong>闭包的缺点:</strong></p> <ul><li>被引用的私有变量不能被销毁，增大了内存的消耗，造成内存泄露</li> <li>闭包涉及跨域访问，会导致性能损失</li></ul> <p><strong>闭包的作用</strong></p> <ul><li>使得函数内部的变量在函数执行完之后，仍然存活在内存中(延长了局部变量的生命周期)</li> <li>让函数外部可以操作到函数内部的数据</li></ul> <p><strong>闭包的原理</strong></p> <p>当一个函数返回后，没有其他对象会保存对其的引用。所以，它就可能被 <code>&amp;#x5783;&amp;#x573E;&amp;#x56DE;&amp;#x6536;&amp;#x5668;</code>回收。</p> <p>函数对象中总是有一个 <code>[[scope]]</code>属性，保存着该函数被定义的时候所能够直接访问的作用域对象。所以，当我们在定义嵌套的函数的时候，这个嵌套的函数的 <code>[[scope]]</code>就会引用外围函数（Outer function）的当前作用域对象。</p> <p>如果我们将这个嵌套函数返回,并被另一个标识符所引用的话,那么这个嵌套函数及其[[scope]]所引用的作用作用域对象就不会被垃圾回收器所销毁,这个对象就会一直存活在内存中,我们可以通过这个作用于对象获取到外部函数的属性和值。</p> <p>这就是闭包的原理</p> <h2 id="_2-this-call-apply-bind"><a href="#_2-this-call-apply-bind" class="header-anchor">#</a> 2.this/call/apply/bind</h2> <h3 id="_1-this的指向"><a href="#_1-this的指向" class="header-anchor">#</a> 1.this的指向</h3> <blockquote><p>函数的this是在函数调用时才绑定的,它的指向完全取决于函数的调用位置(也就是函数的调用方法),为了搞清楚 <code>this</code>的指向是什么，必须知道相关函数是如何调用的</p></blockquote> <p><strong>在全局上下文中:</strong></p> <p>非严格模式和严格模式中this都指向顶层对象(在浏览器中是 <code>window</code>)</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">this</span> <span class="token operator">===</span> window
<span class="token string">'use strict'</span>
<span class="token keyword">this</span> <span class="token operator">===</span> window<span class="token punctuation">;</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'若川'</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div><p><strong>普通函数调用模式</strong></p> <div class="language- extra-class"><pre class="language-text"><code>// &amp;#x975E;&amp;#x4E25;&amp;#x683C;&amp;#x6A21;&amp;#x5F0F;
var name = 'window';
var doSth = function(){
    console.log(this.name);
}
doSth(); // 'window'
&amp;#x590D;&amp;#x5236;&amp;#x4EE3;&amp;#x7801;
</code></pre></div><p>你可能会误以为 <code>window.doSth()</code>是调用的，所以是指向 <code>window</code>。虽然本例中 <code>window.doSth</code>确实等于 <code>doSth</code>。 <code>name</code>等于 <code>window.name</code>。上面代码中这是因为在 <code>ES5</code>中，全局变量是挂载在顶层对象（浏览器是 <code>window</code>）中。 事实上，并不是如此。</p> <div class="language- extra-class"><pre class="language-text"><code>// &amp;#x975E;&amp;#x4E25;&amp;#x683C;&amp;#x6A21;&amp;#x5F0F;
let name2 = 'window2';
let doSth2 = function(){
    console.log(this === window);
    console.log(this.name2);
}
doSth2() // true, undefined
&amp;#x590D;&amp;#x5236;&amp;#x4EE3;&amp;#x7801;
</code></pre></div><p>这个例子中 <code>let</code>没有给顶层对象中（浏览器是window）添加属性， <code>window.name2&amp;#x548C;window.doSth</code>都是 <code>undefined</code>。</p> <p>严格模式中，普通函数中的 <code>this</code>则表现不同，表现为 <code>undefined</code>。</p> <div class="language- extra-class"><pre class="language-text"><code>// &amp;#x4E25;&amp;#x683C;&amp;#x6A21;&amp;#x5F0F;
'use strict'
var name = 'window';
var doSth = function(){
    console.log(typeof this === 'undefined');
    console.log(this.name);
}
doSth(); // true&amp;#xFF0C;// &amp;#x62A5;&amp;#x9519;&amp;#xFF0C;&amp;#x56E0;&amp;#x4E3A;this&amp;#x662F;undefined
&amp;#x590D;&amp;#x5236;&amp;#x4EE3;&amp;#x7801;
</code></pre></div><p>看过的《你不知道的 <code>JavaScript</code>》上卷的读者，应该知道书上将这种叫做默认绑定。 对 <code>call</code>， <code>apply</code>熟悉的读者会类比为：</p> <div class="language- extra-class"><pre class="language-text"><code>doSth.call(undefined);
doSth.apply(undefined);
&amp;#x590D;&amp;#x5236;&amp;#x4EE3;&amp;#x7801;
</code></pre></div><p>效果是一样的， <code>call</code>， <code>apply</code>作用之一就是用来修改函数中的 <code>this</code>指向为第一个参数的。 第一个参数是 <code>undefined</code>或者 <code>null</code>，非严格模式下，是指向 <code>window</code>。严格模式下，就是指向第一个参数。后文详细解释。
经常有这类代码（回调函数），其实也是普通函数调用模式。</p> <div class="language- extra-class"><pre class="language-text"><code>var name = '&amp;#x82E5;&amp;#x5DDD;';
setTimeout(function(){
    console.log(this.name);
}, 0);
// &amp;#x8BED;&amp;#x6CD5;
setTimeout(fn | code, 0, arg1, arg2, ...)
// &amp;#x4E5F;&amp;#x53EF;&amp;#x4EE5;&amp;#x662F;&amp;#x4E00;&amp;#x4E32;&amp;#x4EE3;&amp;#x7801;&amp;#x3002;&amp;#x4E5F;&amp;#x53EF;&amp;#x4EE5;&amp;#x4F20;&amp;#x9012;&amp;#x5176;&amp;#x4ED6;&amp;#x51FD;&amp;#x6570;
// &amp;#x7C7B;&amp;#x6BD4; setTimeout&amp;#x51FD;&amp;#x6570;&amp;#x5185;&amp;#x90E8;&amp;#x8C03;&amp;#x7528;fn&amp;#x6216;&amp;#x8005;&amp;#x6267;&amp;#x884C;&amp;#x4EE3;&amp;#x7801;`code`&amp;#x3002;
fn.call(undefined, arg1, arg2, ...);
&amp;#x590D;&amp;#x5236;&amp;#x4EE3;&amp;#x7801;
</code></pre></div><p><strong>对象中的函数（方法）调用模式</strong></p> <div class="language- extra-class"><pre class="language-text"><code>var name = 'window';
var doSth = function(){
    console.log(this.name);
}
var student = {
    name: '&amp;#x82E5;&amp;#x5DDD;',
    doSth: doSth,
    other: {
        name: 'other',
        doSth: doSth,
    }
}
student.doSth(); // '&amp;#x82E5;&amp;#x5DDD;'
student.other.doSth(); // 'other'
// &amp;#x7528;call&amp;#x7C7B;&amp;#x6BD4;&amp;#x5219;&amp;#x4E3A;&amp;#xFF1A;
student.doSth.call(student);
// &amp;#x7528;call&amp;#x7C7B;&amp;#x6BD4;&amp;#x5219;&amp;#x4E3A;&amp;#xFF1A;
student.other.doSth.call(student.other);
&amp;#x590D;&amp;#x5236;&amp;#x4EE3;&amp;#x7801;
</code></pre></div><p>但往往会有以下场景，把对象中的函数赋值成一个变量了。 这样其实又变成普通函数了，所以使用普通函数的规则（默认绑定）。</p> <div class="language- extra-class"><pre class="language-text"><code>var studentDoSth = student.doSth;
studentDoSth(); // 'window'
// &amp;#x7528;call&amp;#x7C7B;&amp;#x6BD4;&amp;#x5219;&amp;#x4E3A;&amp;#xFF1A;
studentDoSth.call(undefined);
&amp;#x590D;&amp;#x5236;&amp;#x4EE3;&amp;#x7801;
</code></pre></div><p>** <code>call&amp;#x3001;apply&amp;#x3001;bind</code> 调用模式**</p> <p>上文提到 <code>call</code>、 <code>apply</code>，这里详细解读一下。先通过 <code>MDN</code>认识下 <code>call</code>和 <code>apply</code> <a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FFunction%2Fcall" target="_blank" rel="noopener noreferrer">MDN 文档：Function.prototype.call()<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> <strong>语法</strong></p> <div class="language- extra-class"><pre class="language-text"><code>fun.call(thisArg, arg1, arg2, ...)
&amp;#x590D;&amp;#x5236;&amp;#x4EE3;&amp;#x7801;
</code></pre></div><p><strong>thisArg</strong>
在 <code>fun</code>函数运行时指定的 <code>this</code>值。需要注意的是，指定的 <code>this</code>值并不一定是该函数执行时真正的 <code>this</code>值，如果这个函数处于 <strong>非严格模式</strong>下，则指定为 <code>null</code>和 <code>undefined</code>的 <code>this</code>值会自动指向全局对象(浏览器中就是 <code>window</code>对象)，同时值为原始值(数字，字符串，布尔值)的 <code>this</code>会指向该原始值的自动包装对象。
<strong>arg1, arg2, ...</strong>
指定的参数列表
<strong>返回值</strong>
返回值是你调用的方法的返回值，若该方法没有返回值，则返回 <code>undefined</code>。<br> <code>apply</code>和 <code>call</code>类似。只是参数不一样。它的参数是数组（或者类数组）。</p> <p>根据参数 <code>thisArg</code>的描述，可以知道， <code>call</code>就是改变函数中的 <code>this</code>指向为 <code>thisArg</code>，并且执行这个函数，这也就使 <code>JS</code>灵活很多。严格模式下， <code>thisArg</code>是原始值是值类型，也就是原始值。不会被包装成对象。举个例子：</p> <div class="language- extra-class"><pre class="language-text"><code>var doSth = function(name){
    console.log(this);
    console.log(name);
}
doSth.call(2, '&amp;#x82E5;&amp;#x5DDD;'); // Number{2}, '&amp;#x82E5;&amp;#x5DDD;'
var doSth2 = function(name){
    'use strict';
    console.log(this);
    console.log(name);
}
doSth2.call(2, '&amp;#x82E5;&amp;#x5DDD;'); // 2, '&amp;#x82E5;&amp;#x5DDD;'
&amp;#x590D;&amp;#x5236;&amp;#x4EE3;&amp;#x7801;
</code></pre></div><p>虽然一般不会把 <code>thisArg</code>参数写成值类型。但还是需要知道这个知识。 之前写过一篇文章：<a href="https://juejin.cn/post/6844903728147857415" target="_blank" rel="noopener noreferrer">面试官问：能否模拟实现 <code>JS</code>的 <code>call</code>和 <code>apply</code>方法<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 就是利用对象上的函数 <code>this</code>指向这个对象，来模拟实现 <code>call</code>和 <code>apply</code>的。感兴趣的读者思考如何实现，再去看看笔者的实现。</p> <p><code>bind</code>和 <code>call</code>和 <code>apply</code>类似，第一个参数也是修改 <code>this</code>指向，只不过返回值是新函数，新函数也能当做构造函数（ <code>new</code>）调用。 <a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FFunction%2Fbind" target="_blank" rel="noopener noreferrer">MDN Function.prototype.bind<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <blockquote><p><code>bind()</code>方法创建一个新的函数， 当这个新函数被调用时 <code>this</code>键值为其提供的值，其参数列表前几项值为创建时指定的参数序列。</p></blockquote> <p><strong>语法：</strong> fun.bind(thisArg[, arg1[, arg2[, ...]]])
<strong>参数：</strong> <strong>thisArg</strong> 调用绑定函数时作为this参数传递给目标函数的值。 如果使用 <code>new</code>运算符构造绑定函数，则忽略该值。当使用 <code>bind</code>在 <code>setTimeout</code>中创建一个函数（作为回调提供）时，作为 <code>thisArg</code>传递的任何原始值都将转换为 <code>object</code>。如果没有提供绑定的参数，则执行作用域的 <code>this</code>被视为新函数的 <code>thisArg</code>。 <strong>arg1, arg2, ...</strong> 当绑定函数被调用时，这些参数将置于实参之前传递给被绑定的方法。 <strong>返回值</strong> 返回由指定的 <code>this</code>值和初始化参数改造的原函数拷贝。</p> <p><strong>构造函数调用模式</strong></p> <div class="language- extra-class"><pre class="language-text"><code>function Student(name){
    this.name = name;
    console.log(this); // {name: '&amp;#x82E5;&amp;#x5DDD;'}
    // &amp;#x76F8;&amp;#x5F53;&amp;#x4E8E;&amp;#x8FD4;&amp;#x56DE;&amp;#x4E86;
    // return this;
}
var result = new Student('&amp;#x82E5;&amp;#x5DDD;');
&amp;#x590D;&amp;#x5236;&amp;#x4EE3;&amp;#x7801;
</code></pre></div><p>使用 <code>new</code>操作符调用函数，会自动执行以下步骤。</p> <blockquote></blockquote> <ol><li>创建了一个全新的对象。</li> <li>这个对象会被执行 <code>[[Prototype]]</code>（也就是 <code>__proto__</code>）链接。</li> <li>生成的新对象会绑定到函数调用的 <code>this</code>。</li> <li>通过 <code>new</code>创建的每个对象将最终被 <code>[[Prototype]]</code>链接到这个函数的 <code>prototype</code>对象上。</li> <li>如果函数没有返回对象类型 <code>Object</code>(包含 <code>Functoin</code>, <code>Array</code>, <code>Date</code>, <code>RegExg</code>, <code>Error</code>)，那么 <code>new</code>表达式中的函数调用会自动返回这个新的对象。</li></ol> <p>由此可以知道： <code>new</code>操作符调用时， <code>this</code>指向生成的新对象。 <strong>特别提醒一下， <code>new</code> 调用时的返回值，如果没有显式返回对象或者函数，才是返回生成的新对象</strong>。</p> <div class="language- extra-class"><pre class="language-text"><code>function Student(name){
    this.name = name;
    // return function f(){};
    // return {};
}
var result = new Student('&amp;#x82E5;&amp;#x5DDD;');
console.log(result); {name: '&amp;#x82E5;&amp;#x5DDD;'}
// &amp;#x5982;&amp;#x679C;&amp;#x8FD4;&amp;#x56DE;&amp;#x51FD;&amp;#x6570;f&amp;#xFF0C;&amp;#x5219;result&amp;#x662F;&amp;#x51FD;&amp;#x6570;f&amp;#xFF0C;&amp;#x5982;&amp;#x679C;&amp;#x662F;&amp;#x5BF9;&amp;#x8C61;{}&amp;#xFF0C;&amp;#x5219;result&amp;#x662F;&amp;#x5BF9;&amp;#x8C61;{}
&amp;#x590D;&amp;#x5236;&amp;#x4EE3;&amp;#x7801;
</code></pre></div><p>很多人或者文章都忽略了这一点，直接简单用 <code>typeof</code>判断对象。虽然实际使用时不会显示返回，但面试官会问到。</p> <p><strong>总结</strong></p> <p>如果要判断一个运行中的函数的this绑定，就需要找到这个函数的直接调用位置.找到之后就可以顺序应用下面这四条规则来判断this的指向</p> <ol><li><strong>普通函数调用</strong>:在严格模式下绑定到 <code>undefined</code>,否则绑定到全局对象</li> <li><strong>构造函数形式调用</strong>:绑定到新创建的实例对象</li> <li><strong>对象上的函数调用</strong>:帮到到那个对象</li> <li><strong>call、apply、bind调用</strong>:在非严格模式下,this为函数传入的第一个参数,如果第一个参数为 <code>null</code>或者 <code>undefined</code>， <code>this</code>会指向全局对象(浏览器中就是window对象)</li></ol> <p><strong>箭头函数的this</strong>:不会使用上文的四条标准的绑定规则,而是 <strong>根据当前的词法作用域来决定this。</strong></p> <p>箭头函数没有自己的this、super、argument和new.target绑定,所以 <strong>必须通过查找作用域链来决定其值</strong>. <strong>如果箭头函数被非箭头函数包含,则this绑定的是最近一层非箭头函数的this,否则this的值会被设置位全局对象.</strong></p> <h3 id="_2-call"><a href="#_2-call" class="header-anchor">#</a> 2.call</h3> <blockquote><p>call()方法的作用是在使用 <strong>一个指定的this值</strong>和 <strong>若干个指定的参数值</strong>的前提下调用某个函数或方法</p></blockquote> <p>举个栗子</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> foo <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">value</span><span class="token operator">:</span> <span class="token number">1</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">bar</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>手写实现call方法</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">ts_call</span><span class="token punctuation">(</span><span class="token parameter">obj<span class="token punctuation">,</span><span class="token operator">...</span>args</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    obj <span class="token operator">=</span> obj <span class="token operator">||</span> window<span class="token punctuation">;</span>

    <span class="token keyword">const</span> fn <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    obj<span class="token punctuation">[</span>fn<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>

    obj<span class="token punctuation">[</span>fn<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">delete</span> obj<span class="token punctuation">[</span>fn<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token parameter">age</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">我叫</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">今年</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>age<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">岁了!</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> testobj2 <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'zzm'</span>
<span class="token punctuation">}</span>
fn<span class="token punctuation">.</span><span class="token function">cs_call</span><span class="token punctuation">(</span>testobj2<span class="token punctuation">,</span><span class="token number">18</span><span class="token punctuation">)</span>

</code></pre></div><h3 id="_3-apply"><a href="#_3-apply" class="header-anchor">#</a> 3.apply</h3> <blockquote><p>apply的方法与call类似,不同之处在于 <strong>apply参数以数组的方式传递</strong>,所以call能实现的需求，用apply也同样可以</p></blockquote> <p>手写实现apply方法</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">cs_apply</span><span class="token punctuation">(</span><span class="token parameter">obj<span class="token punctuation">,</span>arg</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    obj <span class="token operator">=</span> obj <span class="token operator">||</span> window<span class="token punctuation">;</span>

    <span class="token keyword">const</span> fn <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    obj<span class="token punctuation">[</span>fn<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>

    obj<span class="token punctuation">[</span>fn<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">delete</span> obj<span class="token punctuation">[</span>fn<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token parameter">age<span class="token punctuation">,</span>hobby</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">我叫</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">今年</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>age<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">岁了我喜欢</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>hobby<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> testobj2 <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'zzm'</span>
<span class="token punctuation">}</span>
fn<span class="token punctuation">.</span><span class="token function">cs_apply</span><span class="token punctuation">(</span>testobj2<span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">18</span><span class="token punctuation">,</span><span class="token string">'睡觉'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

</code></pre></div><h3 id="_4-bind"><a href="#_4-bind" class="header-anchor">#</a> 4.bind</h3> <blockquote><p>bind()函数会创建一个新函数(称之为绑定函数)</p></blockquote> <ul><li>bind是ES5新增的一个方法</li> <li>传参和call或apply类似</li> <li>不会执行对应的函数，call或apply会自动执行对应的函数</li> <li>返回对函数的引用</li></ul> <p>**下面例子：**当点击网页时， <code>EventClick</code>被触发执行，输出 <code>JSLite.io p1 p2</code>, 说明 <code>EventClick</code>中的 <code>this</code>被 <code>bind</code>改变成了 <code>obj</code>对象。如果你将 <code>EventClick.bind(obj,'p1','p2')</code> 变成 <code>EventClick.call(obj,'p1','p2')</code> 的话，页面会直接输出 <code>JSLite.io p1 p2</code></p> <div class="language- extra-class"><pre class="language-text"><code>var obj = {name:'JSLite.io'};/** * &amp;#x7ED9;document&amp;#x6DFB;&amp;#x52A0;click&amp;#x4E8B;&amp;#x4EF6;&amp;#x76D1;&amp;#x542C;&amp;#xFF0C;&amp;#x5E76;&amp;#x7ED1;&amp;#x5B9A;EventClick&amp;#x51FD;&amp;#x6570; * &amp;#x901A;&amp;#x8FC7;bind&amp;#x65B9;&amp;#x6CD5;&amp;#x8BBE;&amp;#x7F6E;EventClick&amp;#x7684;this&amp;#x4E3A;obj&amp;#xFF0C;&amp;#x5E76;&amp;#x4F20;&amp;#x9012;&amp;#x53C2;&amp;#x6570;p1,p2 */document.addEventListener('click',EventClick.bind(obj,'p1','p2'),false);//&amp;#x5F53;&amp;#x70B9;&amp;#x51FB;&amp;#x7F51;&amp;#x9875;&amp;#x65F6;&amp;#x89E6;&amp;#x53D1;&amp;#x5E76;&amp;#x6267;&amp;#x884C;function EventClick(a,b){    console.log(            this.name, //JSLite.io            a, //p1            b  //p2    )}// JSLite.io p1 p2
</code></pre></div><p>手写bind</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">cs_bind</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">obj<span class="token punctuation">,</span><span class="token operator">...</span>args</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    obj <span class="token operator">=</span> obj <span class="token operator">||</span> window<span class="token punctuation">;</span>    <span class="token keyword">const</span> fn <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    obj<span class="token punctuation">[</span>fn<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> _this <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> <span class="token function-variable function">res</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>innerArgs</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token keyword">instanceof</span> <span class="token class-name">_this</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
</code></pre></div><h2 id="_3-原型-继承"><a href="#_3-原型-继承" class="header-anchor">#</a> 3.原型/继承</h2> <h3 id="_1-原型"><a href="#_1-原型" class="header-anchor">#</a> 1.原型</h3> <p><strong>原型链经典神图</strong></p> <p><img src="https://img-blog.csdnimg.cn/img_convert/00272ac276de8a896d9c020c49da9c0a.png" alt=""></p> <ul><li>function Foo 就是一个方法，比如JavaScript 中内置的 Array、String 等</li> <li>function Object 就是一个 Object</li> <li>function Function 就是 Function</li> <li>以上都是 function，所以 <code>.__proto__</code>都是 <code>Function.prototype</code></li> <li>再次强调，String、Array、Number、Function、Object都是 function</li></ul> <p><strong>prototype的定义</strong></p> <p>在规范里,prototype被定义为: <strong>给其他对象提供共享属性的对象</strong></p> <p>也就是说prototype自己也是对象,只是被用来承担某个只能罢了</p> <p><strong>prototype描述的是两个对象之间的某种关系(其中一个对象为另一个对象提供属性访问权限).所有对象都可以作为另一个对象的prototype来使用</strong></p> <p><strong>函数对象和普通对象</strong></p> <p>在JavaScript中, <strong>万物皆对象</strong>,但是不同的对象是存在着差异性的.</p> <p>在JavaScript中，我们将对象分为函数对象和普通对象, <strong>函数对象就是JavaScript用函数来模拟的类实现</strong>, <strong>Object</strong>和 <strong>Function</strong>就是典型的函数对象</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">fun1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token function-variable function">fun2</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">const</span> fun3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Function</span><span class="token punctuation">(</span><span class="token string">'name'</span><span class="token punctuation">,</span><span class="token string">'console.log(name)'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> obj1 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">const</span> obj2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> obj3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">fun1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> obj4 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">new</span> <span class="token function">Function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> Object<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>上述代码中， <code>obj1</code>， <code>obj2</code>， <code>obj3</code>， <code>obj4</code>都是普通对象， <code>fun1</code>， <code>fun2</code>， <code>fun3</code> 都是 <code>Function</code> 的实例，也就是函数对象。</p> <p>总结: <strong>所有的Function的实例都是函数对象,其他的均为普通对象,包括Function实例的实例</strong></p> <p><img src="https://img-blog.csdnimg.cn/img_convert/6417aae15ee7af45cb9b6bb205fa5b14.webp?x-oss-process=image/format,png" alt=""></p> <p><strong>JavaScript中万物皆对象,而对象皆出自构造函数</strong></p> <p>对于 <strong>Function</strong>对象:</p> <div class="language-js extra-class"><pre class="language-js"><code>Function<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">Function</span><span class="token punctuation">.</span>prototype
</code></pre></div><p><strong>__ proto__</strong></p> <p>首先我们需要明确:</p> <ul><li><strong>__ proto__ 和 constructor</strong>是 <strong>对象</strong>独有的</li> <li><strong>prototype</strong>属性是 <strong>函数</strong>独有的</li></ul> <p>但是在JavaScript中,函数也是一种特殊的对象, <strong>所以函数也拥有 <code>__proto__</code> 和 <code>constructor</code> 属性</strong></p> <p>结合上面我们介绍的 <code>Object</code> 和 <code>Function</code> 的关系，看一下代码和关系图</p> <div class="language- extra-class"><pre class="language-text"><code> function Person(){&amp;#x2026;}; let nealyang = new Person();
</code></pre></div><p><img src="https://img-blog.csdnimg.cn/img_convert/3653af9958af60e2bb4095cc7ac700cd.webp?x-oss-process=image/format,png" alt=""></p> <p>再梳理上图关系之前，我们再来讲解下 <code>__proto__</code>。</p> <p><img src="https://img-blog.csdnimg.cn/img_convert/9a6a7580aad1e6b7adb87303d1049a1d.webp?x-oss-process=image/format,png" alt=""></p> <p>这里我们需要知道的是， <code>__proto__</code>是对象所独有的，并且 <code>__proto__</code>是 <strong>一个对象指向另一个对象</strong>，也就是他的原型对象。我们也可以理解为父类对象。它的作用就是当你在访问一个对象属性的时候，如果该对象内部不存在这个属性，那么就回去它的 <code>__proto__</code>属性所指向的对象（父类对象）上查找，如果父类对象依旧不存在这个属性，那么就回去其父类的 <code>__proto__</code>属性所指向的父类的父类上去查找。以此类推，知道找到 <code>null</code>。而这个查找的过程，也就构成了我们常说的 <strong>原型链</strong>。</p> <p><strong>原型链就是根据对象的__ proto __指向,一层一层连接起来的具有关联性的对象集合</strong></p> <p><strong>prototype</strong></p> <p>prototype 被定义为： <strong>给其它对象提供共享属性的对象</strong>。 <code>prototype</code> 自己也是对象，只是被用以承担某个职能罢了</p> <p>所有对象都可以作为另一个对象的 <strong>prototype</strong>使用</p> <p><img src="https://img-blog.csdnimg.cn/img_convert/8287fd4134957ad56745ccead88e5556.webp?x-oss-process=image/format,png" alt=""></p> <p><strong>任何函数在创建的时候，都会默认给该函数添加 <code>prototype</code> 属性.</strong></p> <p><strong>constructor</strong></p> <p><strong>constructor</strong>属性也是对象所独有的, <strong>他是一个对象指向同一个函数，这个函数就是该对象的构造函数</strong></p> <p>每个对象都有其对应的构造函数,它由本身或者继承而来.</p> <p><strong>函数.prototype.constructor</strong>=== <strong>该函数本身</strong></p> <p><strong>constructor属性只有prototype对象才有</strong>,函数在创建的时候,JavaScript会同时创建一个该函数对应的prototype对象, <strong>而函数创建的对象.proto === 该函数.prototype</strong></p> <p>通过函数创建的对象即使自己没有 <code>constructor</code>属性，它也能通过 <code>__proto__</code>找到对应的 <code>constructor</code>，所以 <strong>任何对象最终都可以找到其对应的构造函数。</strong></p> <p><img src="https://img-blog.csdnimg.cn/img_convert/51d219f0bbdf1d22c4a3cf37a1137d93.webp?x-oss-process=image/format,png" alt=""></p> <p><strong>原型链</strong></p> <p><strong>原型链就是根据对象的__ proto __指向,一层一层连接起来的具有关联性的对象集合</strong></p> <p><img src="https://img-blog.csdnimg.cn/img_convert/548c6b76d402076fff277355d40a29d6.webp?x-oss-process=image/format,png" alt=""></p> <p><strong>typeof</strong>&amp;&amp; <strong>instanceof</strong>原理</p> <p><strong>typeof</strong></p> <p>用于判断变量的类型,可以判断的类型有: <strong>number</strong>、 <strong>undefined</strong>、 <strong>String</strong>、 <strong>Boolean</strong>、 <strong>function</strong>、 <strong>object</strong>、 <strong>symbol</strong>，但是 <strong>typeof在判断object时不能明确的告诉你属于哪一类object</strong></p> <p>所以 <strong>一般不用typeof来判断object的类型</strong></p> <p>为什么 <strong>typeof null</strong> 返回' <strong>object</strong>'？</p> <p><strong>因为null代表的是空指针对象,所以typeof null 为object</strong></p> <p>具体原因:在 JavaScript 最初的实现中，JavaScript 中的值是由一个表示类型的标签和实际数据值表示的。对象的类型标签是 0。由于 <code>null</code> 代表的是空指针（大多数平台下值为 0x00），因此， <code>null</code> 的类型标签是 0， <code>typeof null</code> 也因此返回 <code>&quot;object&quot;</code></p> <p><strong>instanceof</strong></p> <p><code>instanceof</code> 运算符用来检测 <code>constructor.prototype</code> 是否存在于参数 <code>object</code> 的原型链上。与 <code>typeof</code> 方法不同的是， <code>instanceof</code> 方法要求开发者明确地确认对象为某特定类型。</p> <p><strong>instanceof</strong>可以判断 <strong>一个实例是否是其父类型或者祖先类型的实例。</strong></p> <p><strong>instanceof</strong>是如何进行判断的?</p> <ul><li>表达式**:A instanceof B**:如果B的显式原型(prototype)对象在A的原型链上,返回true,否则返回false</li></ul> <p><strong>手写instanceof</strong></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">_instanceof</span><span class="token punctuation">(</span><span class="token parameter">child<span class="token punctuation">,</span>father</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">const</span> fp <span class="token operator">=</span>  father<span class="token punctuation">.</span>prototype       <span class="token keyword">let</span> cp <span class="token operator">=</span> child<span class="token punctuation">.</span>__proto__    <span class="token keyword">while</span><span class="token punctuation">(</span>cp<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>cp<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> father<span class="token punctuation">.</span>protype<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        cp <span class="token operator">=</span> cp<span class="token punctuation">.</span>__proto__<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object <span class="token keyword">instanceof</span> <span class="token class-name">Object</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p><strong>为什么 <code>Object</code> 和 <code>Function</code> <code>instanceof</code> 自己等于 <code>true</code> ，而其他类 <code>instanceof</code> 自己却又不等于 <code>true</code> 呢？如何解释？</strong></p> <ul><li><code>Object instanceof Object</code></li> <li><code>Function instanceof Function</code></li> <li><code>Foo instanceof Foo</code></li></ul> <h3 id="_2-继承"><a href="#_2-继承" class="header-anchor">#</a> 2.继承</h3> <p>在JavaScript中,有两类原型继承的方式: <strong>显式继承</strong>和 <strong>隐式继承</strong></p> <h4 id="new"><a href="#new" class="header-anchor">#</a> <strong>new</strong></h4> <p><strong>new用来创建构造函数的实例对象</strong></p> <p><strong>手写new</strong></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">myNew</span><span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span><span class="token operator">...</span>args</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    obj<span class="token punctuation">.</span>__proto__ <span class="token operator">=</span> fn<span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>
</code></pre></div><h4 id="类式继承"><a href="#类式继承" class="header-anchor">#</a> <strong>类式继承</strong></h4> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">SuperClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>superValue <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token class-name">SuperClass</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">getSuperValue</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>superValue<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">SubClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>subValue <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token class-name">SubClass</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SuperClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">SubClass</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">getSubValue</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>subValue<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">const</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> instance  <span class="token keyword">instanceof</span> <span class="token class-name">SuperClass</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>虽然实现起来清晰简洁，但是这种继承方式有两个缺点：</p> <ul><li>由于子类通过其原型prototype对父类实例化，继承了父类，所以说父类中如果共有属性是引用类型，就会在子类中被所有的实例所共享，因此一个子类的实例更改子类原型从父类构造函数中继承的共有属性就会直接影响到其他的子类</li> <li>由于子类实现的继承是靠其原型prototype对父类进行实例化实现的，因此在创建父类的时候，是无法向父类传递参数的。因而在实例化父类的时候也无法对父类构造函数内的属性进行初始化</li></ul> <h5 id="构造函数继承"><a href="#构造函数继承" class="header-anchor">#</a> <strong>构造函数继承</strong></h5> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">SuperClass</span><span class="token punctuation">(</span><span class="token parameter">id</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>books <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'js'</span><span class="token punctuation">,</span><span class="token string">'css'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> id<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token class-name">SuperClass</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">showBooks</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>books<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">SubClass</span><span class="token punctuation">(</span><span class="token parameter">id</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">SuperClass</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span>id<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">const</span> instance1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubClass</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> instance2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubClass</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>instance1<span class="token punctuation">.</span>books<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'html'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>instance1<span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>instance2<span class="token punctuation">)</span>instance1<span class="token punctuation">.</span><span class="token function">showBooks</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p><code>SuperClass.call(this,id)</code>当然就是构造函数继承的核心语句了.由于父类中给this绑定属性，因此子类自然也就继承父类的共有属性。由于这种类型的继承没有涉及到原型 <code>prototype</code>，所以父类的原型方法自然不会被子类继承，而如果想被子类继承，就必须放到构造函数中，这样创建出来的每一个实例都会单独的拥有一份而不能共用，这样就违背了代码复用的原则，所以综合上述两种，我们提出了组合式继承方法</p> <h4 id="组合式继承"><a href="#组合式继承" class="header-anchor">#</a> <strong>组合式继承</strong></h4> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">SuperClass</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>   <span class="token keyword">this</span><span class="token punctuation">.</span>books <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'Js'</span><span class="token punctuation">,</span><span class="token string">'CSS'</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token class-name">SuperClass</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">getBooks</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>books<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">SubClass</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span>time</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token function">SuperClass</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>time <span class="token operator">=</span> time<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token class-name">SubClass</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SuperClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">SubClass</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">getTime</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>time<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>
</code></pre></div><p>如上，我们就解决了之前说到的一些问题，但是是不是从代码看，还是有些不爽呢？至少这个 <code>SuperClass</code>的构造函数执行了两遍就感觉非常的不妥.</p> <h4 id="原型式继承"><a href="#原型式继承" class="header-anchor">#</a> <strong>原型式继承</strong></h4> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">inheritObject</span><span class="token punctuation">(</span><span class="token parameter">o</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</code></pre></div><p>原型式继承大致的实现方式如上，是不是想到了我们 <code>new</code>关键字模拟的实现？</p> <p>其实这种方式和类式继承非常的相似，他只是对类式继承的一个封装，其中的过渡对象就相当于类式继承的子类，只不过在原型继承中作为一个普通的过渡对象存在，目的是为了创建要返回的新的实例对象。</p> <div class="language- extra-class"><pre class="language-text"><code>var book = {    name:'js book',    likeBook:['css Book','html book']}var newBook = inheritObject(book);newBook.name = 'ajax book';newBook.likeBook.push('react book');var otherBook = inheritObject(book);otherBook.name = 'canvas book';otherBook.likeBook.push('node book');console.log(newBook,otherBook);&amp;#x590D;&amp;#x5236;&amp;#x4EE3;&amp;#x7801;
</code></pre></div><p>如上代码我们可以看出，原型式继承和类式继承一个样子，对于引用类型的变量，还是存在子类实例共享的情况。</p> <p>所以，我们还有下面的寄生式继承</p> <h4 id="寄生式继承"><a href="#寄生式继承" class="header-anchor">#</a> <strong>寄生式继承</strong></h4> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> book <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token literal-property property">name</span><span class="token operator">:</span><span class="token string">'js book'</span><span class="token punctuation">,</span>    <span class="token literal-property property">likeBook</span><span class="token operator">:</span><span class="token punctuation">[</span><span class="token string">'html book'</span><span class="token punctuation">,</span><span class="token string">'css book'</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">createBook</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</code></pre></div><p>其实寄生式继承就是对原型继承的拓展，一个二次封装的过程，这样新创建的对象不仅仅有父类的属性和方法，还新增了别的属性和方法。</p> <h4 id="寄生组合式继承"><a href="#寄生组合式继承" class="header-anchor">#</a> <strong>寄生组合式继承</strong></h4> <p>回到之前的组合式继承，那时候我们将类式继承和构造函数继承组合使用，但是存在的问题就是子类不是父类的实例，而子类的原型是父类的实例，所以才有了寄生组合式继承</p> <p>而寄生组合式继承是寄生式继承和构造函数继承的组合。但是这里寄生式继承有些特殊，这里他处理不是对象，而是类的原型。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">inheritObject</span><span class="token punctuation">(</span><span class="token parameter">o</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</code></pre></div><p>组合式继承中，通过构造函数继承的属性和方法都是没有问题的，所以这里我们主要探究通过寄生式继承重新继承父类的原型。</p> <p>我们需要继承的仅仅是父类的原型，不用去调用父类的构造函数。换句话说，在构造函数继承中，我们已经调用了父类的构造函数。因此我们需要的就是父类的原型对象的一个副本，而这个副本我们可以通过原型继承拿到，但是这么直接赋值给子类会有问题，因为对父类原型对象复制得到的复制对象p中的 <code>constructor</code>属性指向的不是 <code>subClass</code>子类对象，因此在寄生式继承中要对复制对象p做一次增强，修复起 <code>constructor</code>属性指向性不正确的问题，最后将得到的复制对象p赋值给子类原型，这样子类的原型就继承了父类的原型并且没有执行父类的构造函数。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">SuperClass</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>books<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'js book'</span><span class="token punctuation">,</span><span class="token string">'css book'</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token class-name">SuperClass</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">getName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">SubClass</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span>time</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token function">SuperClass</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>time <span class="token operator">=</span> time<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">inheritPrototype</span><span class="token punctuation">(</span>SubClass<span class="token punctuation">,</span>SuperClass<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">SubClass</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">getTime</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>time<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">var</span> instance1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubClass</span><span class="token punctuation">(</span><span class="token string">'React'</span><span class="token punctuation">,</span><span class="token string">'2017/11/11'</span><span class="token punctuation">)</span><span class="token keyword">var</span> instance2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubClass</span><span class="token punctuation">(</span><span class="token string">'Js'</span><span class="token punctuation">,</span><span class="token string">'2018/22/33'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>instance1<span class="token punctuation">.</span>books<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'test book'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>instance1<span class="token punctuation">.</span>books<span class="token punctuation">,</span>instance2<span class="token punctuation">.</span>books<span class="token punctuation">)</span><span class="token punctuation">;</span>instance2<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>instance2<span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p><img src="https://img-blog.csdnimg.cn/img_convert/1c911c8c12a5ef34476e50111513e2cc.webp?x-oss-process=image/format,png" alt=""></p> <p>这种方式继承其实如上图所示，其中最大的改变就是子类原型中的处理，被赋予父类原型中的一个引用，这是一个对象，因此有一点你需要注意，就是子类在想添加原型方法必须通过prototype.来添加，否则直接赋予对象就会覆盖从父类原型继承的对象了.</p> <h2 id="_4-promise"><a href="#_4-promise" class="header-anchor">#</a> 4.promise</h2> <h3 id="_1-什么是promise-它用来解决什么问题"><a href="#_1-什么是promise-它用来解决什么问题" class="header-anchor">#</a> 1. <strong>什么是promise?它用来解决什么问题?</strong></h3> <blockquote><p>Promise是异步编程的一种解决方案:从语法上讲，promise是一个对象,可以通过它获取异步操作的消息；从本意上讲，他是承诺，承诺他过一段时间会给你一个结果。promise有三种状态: <strong>pending</strong>(等待态)， <strong>fulfiled</strong>(成功态), <strong>rejected</strong>(失败态); <strong>状态一旦改变，就不会再改变</strong>(也就是说promise的操作是不可逆的)， <strong>创造promise实例后，他会立即执行</strong></p></blockquote> <p>promise是用来解决两个问题:</p> <ul><li><strong>回调地狱</strong>，减少多层回调嵌套</li> <li><strong>异步执行</strong>(但是不能说promise是异步的)</li></ul> <h3 id="_2-promise用法"><a href="#_2-promise用法" class="header-anchor">#</a> 2. <strong>promise用法</strong></h3> <p><img src="https://img-blog.csdnimg.cn/img_convert/0e7b5b4f6a0e7920cf19a40e032a84ff.png" alt=""></p> <h4 id="创建promise对象"><a href="#创建promise对象" class="header-anchor">#</a> <strong>创建promise对象</strong></h4> <p>promise是一个 <strong>构造函数</strong>，可以通过 <strong>new</strong>来创建实例对象</p> <p>Promise的构造函数接收 <strong>一个参数</strong>:函数,并且这个函数需要传入 <strong>两个参数</strong>:</p> <ul><li><strong>resolve</strong>:异步操作执行成功后的回调函数</li> <li><strong>reject</strong>:异步操作执行失败后的回调函数</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
</code></pre></div><h4 id="then链式调用"><a href="#then链式调用" class="header-anchor">#</a> <strong>then链式调用</strong></h4> <p>promise可以通过链式调用来减少多层回调嵌套</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span>rehect</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span><span class="token punctuation">{</span>     <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'ok'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>p<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h4 id="reject的用法"><a href="#reject的用法" class="header-anchor">#</a> <strong>reject的用法</strong></h4> <p>把Promise的状态置为rejected，这样我们在then中就能捕捉到，然后执行&quot;失败&quot;情况的回调</p> <div class="language-js extra-class"><pre class="language-js"><code>    <span class="token keyword">let</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
</code></pre></div><p>then中传了两个参数，then方法可以接受两个参数，第一个对应resolve的回调，第二个对应reject的回调。所以我们能够分别拿到他们传过来的数据。多次运行这段代码，你会随机得到下面两种结果：</p> <p><img src="https://img-blog.csdnimg.cn/img_convert/5ffcf0b291b3be3ce47ba8509bdd8f91.webp?x-oss-process=image/format,png" alt="">或者<img src="https://img-blog.csdnimg.cn/img_convert/50e0a3bd67478da7e030a2ff2279e524.webp?x-oss-process=image/format,png" alt=""></p> <h4 id="catch的用法"><a href="#catch的用法" class="header-anchor">#</a> <strong>catch的用法</strong></h4> <p>catch的作用与then的第二个参数类似,用于捕获失败的回调,不过与后者不同的是，在链式调用时，如果代码出错了，他不会报错使js执行停止，而是会进入到catch方法中,并捕获到异常</p> <div class="language-js extra-class"><pre class="language-js"><code>p<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'resolved'</span><span class="token punctuation">,</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>somedata<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>在resolve的回调中，我们console.log(somedata);而somedata这个变量是没有被定义的。如果我们不用Promise，代码运行到这里就直接在控制台报错了，不往下运行了。但是在这里，会得到这样的结果：</p> <p><img src="https://img-blog.csdnimg.cn/img_convert/e449cb120b39ff29e905993a1846a68e.webp?x-oss-process=image/format,png" alt=""></p> <p>也就是说进到catch方法里面去了，而且把错误原因传到了reason参数中。即便是有错误的代码也不会报错了，这与我们的try/catch语句有相同的功能</p> <h4 id="promise-all"><a href="#promise-all" class="header-anchor">#</a> <strong>Promise.all()</strong></h4> <p><strong>用法</strong>:接受一个 <strong>数组</strong>参数，里面的值最终都返回Promise对象</p> <p><strong>特点</strong>:谁执行 <strong>慢</strong>,以谁为准执行回调</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> Promise1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">let</span> Promise2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">let</span> Promise3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">let</span> p <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span><span class="token punctuation">[</span>Promise1<span class="token punctuation">,</span> Promise2<span class="token punctuation">,</span> Promise3<span class="token punctuation">]</span><span class="token punctuation">)</span>p<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token function">funciton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
</code></pre></div><p>应用场景: <em>一些游戏类的素材比较多的应用，打开网页时，预先加载需要用到的各种资源如图片、flash以及各种静态文件。所有的都加载完后，我们再进行页面的初始化。</em></p> <h4 id="promise-race"><a href="#promise-race" class="header-anchor">#</a> <strong>Promise.race()</strong></h4> <p><strong>用法</strong>:接受一个数组参数,里面的值最终都返回Promise对象</p> <p><strong>特点</strong>:谁执行 <strong>快</strong>，以谁为准执行回调</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> promise1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</code></pre></div><h4 id="promise-any"><a href="#promise-any" class="header-anchor">#</a> <strong>Promise.any()</strong></h4> <p><strong>注意</strong>: <strong>Promise.any()尚未被所有浏览器所支持</strong>,node环境下不能使用这个API</p> <p><strong>用法</strong>:接受一个数组参数,里面的值最终都返回Promise对象</p> <p><strong>特点</strong>:只要有一个promise执行成功,那么就返回那个成功的promise</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> promise1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</code></pre></div><h3 id="_3-async-await"><a href="#_3-async-await" class="header-anchor">#</a> 3. <strong>async/await</strong></h3> <h4 id="_1-什么是async"><a href="#_1-什么是async" class="header-anchor">#</a> 1.什么是async?</h4> <p><strong>介绍</strong>:async函数是使用 <code>async</code>关键字声明的函数。 async函数是<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/AsyncFunction" target="_blank" rel="noopener noreferrer"><code>AsyncFunction</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>构造函数的实例， 并且其中允许使用 <code>await</code>关键字。 <code>async</code>和 <code>await</code>关键字让我们可以用一种更简洁的方式写出基于<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="noopener noreferrer"><code>Promise</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>的异步行为，而无需刻意地链式调用 <code>promise</code>。</p> <p><strong>特性</strong>:async函数可能包含0个或者多个<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/await" target="_blank" rel="noopener noreferrer"><code>await</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>表达式。await表达式会暂停整个async函数的执行进程并出让其控制权，只有当其等待的基于promise的异步操作被兑现或被拒绝之后才会恢复进程。promise的解决值会被当作该await表达式的返回值。使用 <code>async</code> / <code>await</code>关键字就可以在异步代码中使用普通的 <code>try</code> / <code>catch</code>代码块。</p> <p><code>async</code> 函数是 <code>Generator</code> 函数的语法糖。使用 关键字 <code>async</code> 来表示，在函数内部使用 <code>await</code> 来表示异步。相较于 <code>Generator</code>， <code>async</code> 函数的改进在于下面四点：</p> <ul><li><strong>内置执行器</strong>。 <code>Generator</code> 函数的执行必须依靠执行器，而 <code>async</code> 函数自带执行器，调用方式跟普通函数的调用一样</li> <li><strong>更好的语义</strong>。 <code>async</code> 和 <code>await</code> 相较于 <code>*</code> 和 <code>yield</code> 更加语义化</li> <li><strong>更广的适用性</strong>。 <code>co</code> 模块约定， <code>yield</code> 命令后面只能是 Thunk 函数或 Promise对象。而 <code>async</code> 函数的 <code>await</code> 命令后面则可以是 Promise 或者 原始类型的值（Number，string，boolean，但这时等同于同步操作）</li> <li><strong>返回值是 Promise</strong>。 <code>async</code> 函数返回值是 Promise 对象，比 Generator 函数返回的 Iterator 对象方便，可以直接使用 <code>then()</code> 方法进行调用</li></ul> <p><code>async</code>是ES7新出的特性，表明当前函数是异步函数，不会阻塞线程导致后续代码停止运行。</p> <h4 id="_2-async函数怎么用"><a href="#_2-async函数怎么用" class="header-anchor">#</a> 2.async函数怎么用?</h4> <p><strong>async</strong>用来声明函数是一个异步函数</p> <p><strong>await</strong>表示紧跟在后面的表达式需要等待结果</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">asyncFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token string">'hello world'</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">asuncFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p><strong>async</strong>函数返回的是一个 <strong>promise</strong>对象,状态为 <strong>resolved</strong>,参数是 <strong>return</strong>的值,所以async函数可以链式调用</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">asyncFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token string">'我后执行'</span><span class="token punctuation">}</span><span class="token function">asyncFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">result</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p><strong>async</strong>函数返回的是一个promise对象，如果再执行过程中函数 <strong>内部抛出异常</strong>或者返回 <strong>reject</strong>，都会是的函数的promise状态变为失败 <strong>rejected</strong>，函数抛出异常后，可以通过 <strong>catch</strong>接收到返回的错误信息</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">asyncFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span>  Promise<span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span><span class="token string">'reason'</span><span class="token punctuation">)</span>
</code></pre></div><p>async函数接收到的返回值,如果不是 <strong>异常</strong>或者 <strong>reject</strong>，则判定成功,即 <strong>resolve</strong></p> <p>以下结果会使async函数判定 <strong>失败</strong>:</p> <ul><li>内部含有直接使用并且未声明的变量或者函数。</li> <li>内部抛出一个错误 <code>throw new Error</code>或者返回 <code>reject</code>状态 <code>return Promise.reject('&amp;#x6267;&amp;#x884C;&amp;#x5931;&amp;#x8D25;')</code></li> <li>函数方法执行出错（🌰：Object使用push()）等等...</li></ul> <p>async函数如果需要返回结果,都必须使用 <strong>return</strong>来返回,不论是 <strong>reject</strong>还是 <strong>resolve</strong>都需要使用return，不然就会返回一个值为 <strong>undefined</strong> 的 <strong>resolved</strong>(成功)状态</p> <h4 id="_3-await是什么"><a href="#_3-await是什么" class="header-anchor">#</a> 3.await是什么</h4> <p><strong>await</strong>的意思是 <strong>async wait</strong>(异步等待), <strong>await必须配合async使用</strong>， <strong>async函数必须等到内部所有的await命令的promise执行完,才会返回结果</strong></p> <p><strong>打个比方，await是学生，async是校车，必须等人齐了再开车。</strong></p> <p>就是说，必须等所有 <code>await</code> 函数执行完毕后，才会告诉 <code>promise</code>我成功了还是失败了，执行 <code>then</code>或者 <code>catch</code></p> <div class="language- extra-class"><pre class="language-text"><code>async function awaitReturn() {         return await 1};awaitReturn().then(success =&gt; console.log('&amp;#x6210;&amp;#x529F;', success))             .catch(error =&gt; console.log('&amp;#x5931;&amp;#x8D25;',error))
</code></pre></div><p><img src="https://img-blog.csdnimg.cn/img_convert/0c3eb5f13d3255d0cd0bd55f2435391d.webp?x-oss-process=image/format,png" alt=""></p> <p>async中的await会返回一个 <strong>promise</strong>, <strong>下一个await必须等待上一个await返回promise结果状态才会开始执行</strong></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> time1<span class="token punctuation">;</span><span class="token keyword">let</span> time2<span class="token punctuation">;</span><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>    time1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;第一个函数执行完毕&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>    time2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;第二个函数执行完毕&quot;</span><span class="token punctuation">,</span>time2<span class="token operator">-</span>time1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token function-variable function">timeoutFn</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">timeout</span><span class="token punctuation">)</span><span class="token punctuation">{</span> 	<span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve</span><span class="token punctuation">)</span><span class="token punctuation">{</span>		<span class="token keyword">return</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">timeOut</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">await</span> <span class="token function">timeoutFn</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">await</span> <span class="token function">timeoutFn</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;完成&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">timeOut</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><p>不考虑 <strong>event loop</strong>(事件循环)</p> <p>上面的例子中 两个 <strong>setTimeout</strong>函数会在 <strong>2s</strong>左右(之所以说左右这个词,是因为函数执行会消耗几毫秒时间)，</p> <p>而 <strong>timeOut</strong>函数则需要 <strong>3s</strong>左右的时间才会执行完成,这也说明了下一个 <strong>await</strong>必须等待上一个 <strong>await</strong>返回promise结果状态才会开始执行的结论是正确的</p> <p><strong>await后面的表达式应该返回一个promise，如果不是promise，js内部也会将其转换为一个resolved状态的 promise</strong></p> <h2 id="_5-深浅拷贝"><a href="#_5-深浅拷贝" class="header-anchor">#</a> 5.深浅拷贝</h2> <p>JavaScript的数据类型分为 <strong>基本数据类型</strong>和 <strong>引用数据类型</strong>。</p> <p>对于 <strong>基本数据类型</strong>的拷贝，并没有深浅拷贝的区别，我们所说的 <strong>深浅拷贝都是对于引用数据类型而言的</strong>。</p> <h3 id="什么是浅拷贝"><a href="#什么是浅拷贝" class="header-anchor">#</a> 什么是浅拷贝?</h3> <p>浅拷贝的意思就是只复制引用，而未复制真正的值。</p> <p>当我们浅拷贝一个数组或者对象后，改变这个新的数组或对象,那么被我们拷贝的数组和对象也会改变</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> originArray <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="什么是深拷贝"><a href="#什么是深拷贝" class="header-anchor">#</a> 什么是深拷贝？</h3> <p>深拷贝就是对目标的完全拷贝，不像浅拷贝那样只是复制了一层引用，就连值也都复制了。</p> <p><strong>只要进行了深拷贝，它们老死不相往来，谁也不会影响谁。</strong></p> <p>目前实现深拷贝的方法不多，主要是两种：</p> <ol><li>利用 <code>JSON</code> 对象中的 <code>parse</code> 和 <code>stringify</code></li> <li>利用递归来实现每一层都重新创建对象并赋值</li></ol> <p><strong>利用JSON.stringify/parse的方法实现深拷贝</strong></p> <p>JSON.stringify的作用是 <strong>将一个javascript值转换成json字符串</strong></p> <p>JSON.parse的作用是 <strong>将一个JSON字符串转换成javascript值或对象</strong></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> originArray <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">const</span> cloneArray <span class="token operator">=</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>originArray<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>cloneArray <span class="token operator">===</span> originArray<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>上面的例子可以实现深拷贝,但是这种方式只能适用于一些简单的情况，因为 <strong>在使用HSON.stringify()时， <code>undefined</code> 、 <code>function</code> 、 <code>symbol</code> 会在转换过程中被忽略。。</strong></p> <p>如果对象中含有以上几种类型时，就不能用这个方法进行深拷贝。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> originObj <span class="token operator">=</span> <span class="token punctuation">{</span>  <span class="token literal-property property">name</span><span class="token operator">:</span><span class="token string">'axuebin'</span><span class="token punctuation">,</span>  <span class="token function-variable function">sayHello</span><span class="token operator">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Hello World'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>originObj<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p><strong>使用递归的方法实现深拷贝</strong></p> <p>递归的思想就很简单了，就是对每一层的数据都实现一次 <code>&amp;#x521B;&amp;#x5EFA;&amp;#x5BF9;&amp;#x8C61;-&gt;&amp;#x5BF9;&amp;#x8C61;&amp;#x8D4B;&amp;#x503C;</code> 的操作</p> <h3 id="javascript中的拷贝方法"><a href="#javascript中的拷贝方法" class="header-anchor">#</a> JavaScript中的拷贝方法</h3> <p>JavaScript数组中有两个方法, <strong>concat</strong>和 <strong>slice</strong>,他们都 <strong>不会改变原数组</strong>，而是返回一个新数组</p> <p>所以他们是可以实现对原数组的拷贝的,另外es6新增的 <code>Object.assgn</code> 方法和 <code>...</code> 展开运算符也能实现对对象的拷贝</p> <p>这里只说明结论,不解释详细过程</p> <p><strong>concat</strong></p> <p>该方法可以连接两个或者更多的数组，但是它不会修改已存在的数组，而是返回一个新数组。</p> <p><strong>结论： <code>concat</code> 只是对数组的第一层进行深拷贝。</strong></p> <p><strong>slice</strong></p> <p><strong>结论： <code>slice</code> 只是对数组的第一层进行深拷贝。</strong></p> <p><strong>Object.assign()</strong></p> <p><strong>结论： <code>Object.assign()</code> 拷贝的是属性值。假如源对象的属性值是一个指向对象的引用，它也只拷贝那个引用值</strong></p> <p><strong>... 展开运算符</strong></p> <p><strong>结论： <code>...</code> 实现的是对象第一层的深拷贝。后面的只是拷贝的引用值。</strong></p> <h3 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h3> <ol><li>赋值运算符 <code>=</code> 实现的是浅拷贝，只拷贝对象的引用值；</li> <li>JavaScript 中数组和对象自带的拷贝方法都是&quot;首层浅拷贝&quot;；</li> <li><code>JSON.stringify</code> 实现的是深拷贝，但是对目标对象有要求；</li> <li>若想真正意义上的深拷贝，请递归。</li></ol> <h2 id="_6-event-loop-事件循环"><a href="#_6-event-loop-事件循环" class="header-anchor">#</a> 6.event loop(事件循环)</h2> <p>在学习事件循环之前,我们应该明白: <strong>JavaScript本质上就是一个单线程语言,一切JavaScript的所谓&quot;多线程&quot;都是用单线程模拟出来的</strong></p> <h3 id="什么是事件循环"><a href="#什么是事件循环" class="header-anchor">#</a> <strong>什么是事件循环?</strong></h3> <p>因为js是单线程的,js的任务是按顺序一个一个执行的。但一个任务耗时过长,后面的任务将被阻塞,这是我们不想看到的。所以程序员将任务分为两类:</p> <ul><li><strong>同步任务</strong></li> <li>*<em>异步任务</em></li></ul> <p><strong>任务执行机制:</strong></p> <p><img src="https://img-blog.csdnimg.cn/img_convert/e449e9974db605e1b9088f25d47c0d63.webp?x-oss-process=image/format,png" alt=""></p> <p>导图要表达的内容用文字来表述的话：</p> <ul><li>同步和异步任务分别进入不同的执行&quot;场所&quot;，同步的进入主线程，异步的进入 <strong>Event Table</strong>并注册函数。</li> <li>当指定的事情完成时， <strong>Event Table</strong>会将这个函数移入 <strong>Event Queue</strong>。</li> <li>主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行。</li> <li>上述过程会不断重复，也就是常说的 <strong>Event Loop</strong>(事件循环)。</li></ul> <h3 id="事件循环的一些举例"><a href="#事件循环的一些举例" class="header-anchor">#</a> 事件循环的一些举例</h3> <h4 id="settimeout"><a href="#settimeout" class="header-anchor">#</a> <strong>setTimeout</strong></h4> <p>setTimeout表示执行一个延时函数,他的特点是可以异步延时执行</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'延时3秒'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">3000</span><span class="token punctuation">)</span>
</code></pre></div><p>但是在有些情况下,延时并不准确</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>    <span class="token function">task</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">10000000</span><span class="token punctuation">)</span>
</code></pre></div><p>上例中,sleep()函数是一个 <strong>同步任务</strong>,他直接在主线程中执行,而setTimeout是个 <strong>异步任务</strong>,在任务执行过程中，task()执行的时间却远远大于3s,这时候延时并不准确,这是什么原因?</p> <ul><li><code>task()</code>进入Event Table并注册,计时开始。</li> <li>执行 <code>sleep</code>函数，很慢，非常慢，计时仍在继续。</li> <li>3秒到了，计时事件 <code>timeout</code>完成， <code>task()</code>进入Event Queue，但是 <code>sleep</code>也太慢了吧，还没执行完，只好等着。</li> <li><code>sleep</code>终于执行完了， <code>task()</code>终于从Event Queue进入了主线程执行。</li></ul> <p><strong>setTimeout(fn,0)</strong></p> <p>当setTimeout的延时为0时,是不是意味着他会立即执行呢?</p> <p>答案是: <strong>NO!</strong></p> <p><code>setTimeout(fn,0)</code>的含义是， <strong>指定某个任务在主线程最早可得的空闲时间执行</strong>，意思就是不用再等多少秒了， <strong>只要主线程执行栈内的同步任务全部执行完成，栈为空就马上执行</strong></p> <p>关于 <code>setTimeout</code>要补充的是，即便主线程为空，0毫秒实际上也是达不到的。根据HTML的标准，最低是4毫秒。</p> <h4 id="setinterval"><a href="#setinterval" class="header-anchor">#</a> setInterval</h4> <p><strong>setTimeout表示执行一个定时函数,每经过单位时间,就执行一次回调函数</strong></p> <p>上面说完了 <code>setTimeout</code>，当然不能错过它的孪生兄弟 <code>setInterval</code>。他俩差不多，只不过后者是循环的执行。对于执行顺序来说， <code>setInterval</code>会每隔指定的时间将注册的函数置入Event Queue，如果前面的任务耗时太久，那么同样需要等待。</p> <p>唯一需要注意的一点是，对于 <code>setInterval(fn,ms)</code>来说，我们已经知道不是每过 <code>ms</code>秒会执行一次 <code>fn</code>，而是每过 <code>ms</code>秒，会有 <code>fn</code>进入Event Queue。一旦** <code>setInterval</code>的回调函数 <code>fn</code>执行时间超过了延迟时间 <code>ms</code>，那么就完全看不出来有时间间隔了**。</p> <h3 id="宏任务-macro-task-和微任务-micro-task"><a href="#宏任务-macro-task-和微任务-micro-task" class="header-anchor">#</a> 宏任务(macro-task)和微任务(micro-task)</h3> <p>除了广义上的同步任务和异步任务,我们对任务有更精细的定义:</p> <ul><li><p><strong>macro-task(宏任务)</strong>:包括整体代码script,setTimeout\setInterval...</p></li> <li><p><strong>micro-task(微任务)</strong>:Promise,Process.nextTick...</p></li></ul> <p>核心知识点伪代码;</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> macroTask <span class="token keyword">of</span> macroTaskQueue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</code></pre></div><p>事件循环,宏任务,微任务的关系图:</p> <p><img src="https://img-blog.csdnimg.cn/img_convert/90c95a36d3c9b7615e25a1babed8ae36.webp?x-oss-process=image/format,png" alt=""></p> <p>用一段代码来说明:</p> <div class="language-js extra-class"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'2'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    process<span class="token punctuation">.</span><span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'3'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'4'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'5'</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span>process<span class="token punctuation">.</span><span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'6'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'7'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'8'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'9'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    process<span class="token punctuation">.</span><span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'10'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'11'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'12'</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>第一轮事件循环流程分析如下：</p> <ul><li>整体script作为第一个宏任务进入主线程，遇到 <code>console.log</code>，输出1。</li> <li>遇到 <code>setTimeout</code>，其回调函数被分发到宏任务Event Queue中。我们暂且记为 <code>setTimeout1</code>。</li> <li>遇到 <code>process.nextTick()</code>，其回调函数被分发到微任务Event Queue中。我们记为 <code>process1</code>。</li> <li>遇到 <code>Promise</code>， <code>new Promise</code>直接执行，输出7。 <code>then</code>被分发到微任务Event Queue中。我们记为 <code>then1</code>。</li> <li>又遇到了 <code>setTimeout</code>，其回调函数被分发到宏任务Event Queue中，我们记为 <code>setTimeout2</code>。</li></ul> <p>宏任务Event Queue微任务Event QueuesetTimeout1process1setTimeout2then1</p> <ul><li>上表是第一轮事件循环宏任务结束时各Event Queue的情况，此时已经输出了1和7。</li> <li>我们发现了 <code>process1</code>和 <code>then1</code>两个微任务。</li> <li>执行 <code>process1</code>,输出6。</li> <li>执行 <code>then1</code>，输出8。</li></ul> <p>好了，第一轮事件循环正式结束，这一轮的结果是输出1，7，6，8。那么第二轮时间循环从 <code>setTimeout1</code>宏任务开始：</p> <ul><li>首先输出2。接下来遇到了 <code>process.nextTick()</code>，同样将其分发到微任务Event Queue中，记为 <code>process2</code>。 <code>new Promise</code>立即执行输出4， <code>then</code>也分发到微任务Event Queue中，记为 <code>then2</code>。</li></ul> <p>宏任务Event Queue微任务Event QueuesetTimeout2process2then2</p> <ul><li>第二轮事件循环宏任务结束，我们发现有 <code>process2</code>和 <code>then2</code>两个微任务可以执行。</li> <li>输出3。</li> <li>输出5。</li> <li>第二轮事件循环结束，第二轮输出2，4，3，5。</li> <li>第三轮事件循环开始，此时只剩setTimeout2了，执行。</li> <li>直接输出9。</li> <li>将 <code>process.nextTick()</code>分发到微任务Event Queue中。记为 <code>process3</code>。</li> <li>直接执行 <code>new Promise</code>，输出11。</li> <li>将 <code>then</code>分发到微任务Event Queue中，记为 <code>then3</code>。</li></ul> <p>宏任务Event Queue微任务Event Queueprocess3then3</p> <ul><li>第三轮事件循环宏任务执行结束，执行两个微任务 <code>process3</code>和 <code>then3</code>。</li> <li>输出10。</li> <li>输出12。</li> <li>第三轮事件循环结束，第三轮输出9，11，10，12。</li></ul> <p>整段代码，共进行了三次事件循环，完整的输出为 <strong>1，7，6，8，2，4，3，5，9，11，10，12</strong>。 (请注意，node环境下的事件监听依赖libuv与前端环境不完全相同，输出顺序可能会有误差)</p> <h3 id="如何实现一个事件的订阅与发布"><a href="#如何实现一个事件的订阅与发布" class="header-anchor">#</a> ?如何实现一个事件的订阅与发布</h3> <h2 id="_7-函数式编程"><a href="#_7-函数式编程" class="header-anchor">#</a> 7.函数式编程</h2> <h3 id="什么是函数式编程"><a href="#什么是函数式编程" class="header-anchor">#</a> 什么是函数式编程？</h3> <p>函数式编程（Functional Programming，后面简称FP），维基百科的定义是：</p> <blockquote><p>是一种编程范型，它将电脑运算视为数学上的函数计算，并且避免使用程序状态以及易变对象。函数编程语言最重要的基础是λ演算（lambda calculus）。而且λ演算的函数可以接受函数当作输入（引数）和输出（传出值）。比起命令式编程，函数式编程更加强调程序执行的结果而非执行的过程，倡导利用若干简单的执行单元让计算结果不断渐进，逐层推导复杂的运算，而不是设计一个复杂的执行过程。</p></blockquote> <p>我来尝试理解下这个定义，好像就是说，在敲代码的时候，我要 <strong>把过程逻辑写成函数，定义好输入参数，只关心它的输出结果。而且可以把函数作为输入输出</strong>。感觉好像平常写js时，就是这样的嘛！</p> <p><strong>特性:</strong></p> <ol><li><strong>函数是一等公民</strong>。就是说函数可以跟其他变量一样，可以作为其他函数的输入输出。喔，回调函数就是典型应用。</li> <li><strong>不可变量</strong>。就是说，不能用var跟let咯。按这要求，我似乎有点难写代码。</li> <li><strong>纯函数</strong>。就是没有副作用的函数。这个好理解，就是不修改函数外部的变量。</li> <li><strong>引用透明</strong>。这个也好理解，就是说同样的输入，必定是同样的输出。函数内部不依赖外部状态，如一些全局变量。</li> <li><strong>惰性计算</strong>。大意就是：一个表达式绑定的变量，不是声明的时候就计算出来，而是真正用到它的时候才去计算。</li></ol> <h3 id="函数式编程的优劣势"><a href="#函数式编程的优劣势" class="header-anchor">#</a> 函数式编程的优劣势</h3> <p><strong>优势</strong></p> <ol><li><strong>更好的管理状态</strong>。因为它的宗旨是无状态，或者说更少的状态。而平常DOM的开发中，因为DOM的视觉呈现依托于状态变化，所以不可避免的产生了非常多的状态，而且不同组件可能还相互依赖。以FP来编程，能最大化的减少这些未知、优化代码、减少出错情况。</li> <li><strong>更简单的复用</strong>。极端的FP代码应该是每一行代码都是一个函数，当然我们不需要这么极端。我们尽量的把过程逻辑以更纯的函数来实现，固定输入-&gt;固定输出，没有其他外部变量影响，并且无副作用。这样代码复用时，完全不需要考虑它的内部实现和外部影响。</li> <li><strong>更优雅的组合</strong>。往大的说，网页是由各个组件组成的。往小的说，一个函数也可能是由多个小函数组成的。参考上面第二点，更强的复用性，带来更强大的组合性。</li> <li>隐性好处。减少代码量，提高维护性。</li></ol> <p><strong>劣势</strong></p> <ol><li>JavaScript不能算是严格意义上的函数式语言，很多函数式编程的特性并没有。比如上文说的数组的惰性链求值。为了实现它就得上工具库，或者自己封装实现，提高了代码编写成本。</li> <li>跟过程式相比，它并没有提高性能。有些地方，如果强制用FP去写，由于没有中间变量，还可能会降低性能。</li> <li>代码不易读。这个因人而异，因码而已。特别熟悉FP的人可能会觉得这段代码一目了然。而不熟悉的人，遇到写的晦涩的代码，看着一堆堆lambda演算跟匿名函数 <code>() =&gt; () =&gt; ()</code> 瞬间就懵逼了。看懂代码，得脑子里先演算半小时。</li> <li>学习成本高。一方面继承于上一点。另一方面，很多前端coder，就是因为相对不喜欢一些底层的抽象的编程语言，才来踏入前端坑，你现在又让他们一头扎入FP，显得手足无措。</li></ol> <h3 id="函数柯里化-curry"><a href="#函数柯里化-curry" class="header-anchor">#</a> 函数柯里化(curry)</h3> <p>curry 的概念很简单： <strong>只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。</strong></p> <p><strong>函数柯里化是指一个函数接收参数但不执行,知道所有参数都接到之后再执行</strong></p> <p><strong>实现一个curry函数</strong></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">currying</span><span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span><span class="token operator">...</span>args</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">const</span> length <span class="token operator">=</span> fn<span class="token punctuation">.</span>length    <span class="token keyword">let</span> argArray <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span>args<span class="token punctuation">]</span>    <span class="token keyword">const</span> <span class="token function-variable function">res</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args2</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        argArray <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span>argArray<span class="token punctuation">,</span><span class="token operator">...</span>args2<span class="token punctuation">]</span>
</code></pre></div><h2 id="_8-service-worker-pwa"><a href="#_8-service-worker-pwa" class="header-anchor">#</a> 8.Service Worker/PWA</h2> <h2 id="_9-web-worker"><a href="#_9-web-worker" class="header-anchor">#</a> 9.Web Worker</h2> <h2 id="_10-es6知识"><a href="#_10-es6知识" class="header-anchor">#</a> 10.ES6知识</h2> <p>ES6所增加的知识太多了,给一个传送口</p> <p><a href="https://juejin.cn/post/6844903959283367950" target="_blank" rel="noopener noreferrer">1.5万字概括ES6全部特性(已更新ES2020) - 掘金 (juejin.cn)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><img src="https://img-blog.csdnimg.cn/img_convert/0fc99356fd27c1313561d9127878ce7e.webp?x-oss-process=image/format,png" alt=""></p> <h1 id="_2-css基础"><a href="#_2-css基础" class="header-anchor">#</a> 2.CSS基础</h1> <p><img src="https://img-blog.csdnimg.cn/img_convert/b9d6216b138b48e9f60d03aa580a36de.webp?x-oss-process=image/format,png" alt=""></p> <h2 id="_1-position"><a href="#_1-position" class="header-anchor">#</a> 1.position</h2> <h3 id="什么是position"><a href="#什么是position" class="header-anchor">#</a> 什么是position?</h3> <p>CSS **<code>position</code>**属性用于指定一个元素在文档中的定位方式。<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/top" target="_blank" rel="noopener noreferrer"><code>top</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/right" target="_blank" rel="noopener noreferrer"><code>right</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/bottom" target="_blank" rel="noopener noreferrer"><code>bottom</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/left" target="_blank" rel="noopener noreferrer"><code>left</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 属性则决定了该元素的最终位置。</p> <p><strong>position的属性</strong></p> <ul><li><strong>static</strong>:表示元素按文档流中本应该放置的位置来排版</li> <li><strong>relative</strong>:表示相对定位</li> <li><strong>absolute</strong>:表示绝对定位</li> <li><strong>fixed</strong>：固定定位</li> <li><strong>sticky</strong>:表示粘性定位</li></ul> <p><strong>relative</strong></p> <p><strong>特性</strong>:</p> <ul><li><strong>不脱离文档流</strong></li> <li>默认参照物为此元素 *<em>原位置</em></li></ul> <p><strong>absolute</strong></p> <p>特性:</p> <ul><li><strong>脱离文档流</strong></li> <li>默认参照物为浏览器视窗的 *<em>左上角</em></li></ul> <p>绝对定位元素相对于 _最近的非 <code>static</code> 祖先元素_定位。当这样的祖先元素不存在时，则相对于ICB（inital container block, 初始包含块）。</p> <p>可以查看示例</p> <p><a href="https://codepen.io/zhangzhenming20020615/pen/mdpJeRe" target="_blank" rel="noopener noreferrer">A Pen by 张振明 (codepen.io)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><strong>fixed</strong></p> <p><strong>特性</strong></p> <ul><li><strong>脱离文档流</strong></li> <li>默认参照物为浏览器 *<em>视窗位置</em></li></ul> <p><strong>sticky(粘性定位)</strong></p> <p>单词sticky的中文意思是&quot;粘性的&quot;， <code>position:sticky</code>表现也符合这个粘性的表现。基本上，可以看出是 <code>position:relative</code>和 <code>position:fixed</code>的结合体——当元素在屏幕内，表现为relative，就要滚出显示器屏幕的时候，表现为fixed。</p> <p><strong>特性</strong>:</p> <ul><li><strong>当元素没有到达指定的位置时</strong>,position为 <strong>relative</strong></li> <li><strong>当元素到达指定的位置</strong>,position为 <strong>fixed</strong>，也就是固定住</li> <li>sticky元素的父级元素不能有任何 <code>overflow:visible</code>以外的overflow设置,否则没有粘滞效果</li></ul> <h2 id="_2-行内元素-块级元素"><a href="#_2-行内元素-块级元素" class="header-anchor">#</a> 2.行内元素/块级元素</h2> <h3 id="什么是行内元素"><a href="#什么是行内元素" class="header-anchor">#</a> 什么是行内元素？</h3> <p><strong>行内元素只占据它对应标签的边框所包含的空间</strong></p> <p><strong>一般情况下，行内元素只能包含数据和其他行内元素。</strong></p> <p>行内元素列表:</p> <ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/b" target="_blank" rel="noopener noreferrer">b<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>,<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/big" target="_blank" rel="noopener noreferrer">big<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>,<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/i" target="_blank" rel="noopener noreferrer">i<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>,<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/small" target="_blank" rel="noopener noreferrer">small<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>,<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/tt" target="_blank" rel="noopener noreferrer">tt<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/abbr" target="_blank" rel="noopener noreferrer">abbr<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>,<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/acronym" target="_blank" rel="noopener noreferrer">acronym<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>,<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/cite" target="_blank" rel="noopener noreferrer">cite<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>,<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/code" target="_blank" rel="noopener noreferrer">code<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>,<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/dfn" target="_blank" rel="noopener noreferrer">dfn<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>,<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/em" target="_blank" rel="noopener noreferrer">em<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>,<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/kbd" target="_blank" rel="noopener noreferrer">kbd<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>,<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/strong" target="_blank" rel="noopener noreferrer">strong<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>,<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/samp" target="_blank" rel="noopener noreferrer">samp<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>,<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/var" target="_blank" rel="noopener noreferrer">var<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/a" target="_blank" rel="noopener noreferrer">a<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>,<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/bdo" target="_blank" rel="noopener noreferrer">bdo<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>,<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/br" target="_blank" rel="noopener noreferrer">br<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>,<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/img" target="_blank" rel="noopener noreferrer">img<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>,<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/map" target="_blank" rel="noopener noreferrer">map<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>,<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/object" target="_blank" rel="noopener noreferrer">object<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>,<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/q" target="_blank" rel="noopener noreferrer">q<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>,<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/script" target="_blank" rel="noopener noreferrer">script<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>,<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/span" target="_blank" rel="noopener noreferrer">span<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>,<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/sub" target="_blank" rel="noopener noreferrer">sub<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>,<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/sup" target="_blank" rel="noopener noreferrer">sup<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/button" target="_blank" rel="noopener noreferrer">button<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>,<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/Input" target="_blank" rel="noopener noreferrer">input<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>,<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/label" target="_blank" rel="noopener noreferrer">label<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>,<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/select" target="_blank" rel="noopener noreferrer">select<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>,<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/textarea" target="_blank" rel="noopener noreferrer">textarea<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <h3 id="什么是块级元素"><a href="#什么是块级元素" class="header-anchor">#</a> 什么是块级元素</h3> <p>块级元素占据其父元素（容器）的整个水平空间，垂直空间等于其内容高度，因此创建了一个&quot;块&quot;</p> <p>通常浏览器会在块级元素前后另起一个新行</p> <h3 id="行内元素与块级元素的区别"><a href="#行内元素与块级元素的区别" class="header-anchor">#</a> 行内元素与块级元素的区别</h3> <p>块级元素与行内元素有几个关键区别：</p> <ul><li>格式 默认情况下，块级元素会新起一行。</li> <li>内容模型 一般块级元素可以包含行内元素和其他块级元素。这种结构上的包含继承区别可以使块级元素创建比行内元素更&quot;大型&quot;的结构。</li></ul> <p>HTML 标准中块级元素和行内元素的区别至高出现在 4.01 标准中。在 HTML5，这种区别被一个更复杂的<a href="https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Content_categories" target="_blank" rel="noopener noreferrer">内容类别 (en-US)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>代替。&quot;块级&quot;类别大致相当于 HTML5 中的<a href="https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Content_categories#flow_content" target="_blank" rel="noopener noreferrer">流内容 (en-US)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>类别，而&quot;行内&quot;类别相当于 HTML5 中的<a href="https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Content_categories#phrasing_content" target="_blank" rel="noopener noreferrer">措辞内容 (en-US)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>类别，不过除了这两个还有其他类别。</p> <h3 id="bfc-块格式化上下文"><a href="#bfc-块格式化上下文" class="header-anchor">#</a> BFC(块格式化上下文)</h3> <p><strong>块格式化上下文（Block Formatting Context，BFC）</strong> 是Web页面的可视CSS渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。</p> <p>下列方式会创建 <strong>块格式化上下文</strong>：</p> <ul><li>根元素（ <code>&lt;html&gt;&amp;#xFF09;&lt;/html&gt;</code></li> <li>浮动元素（元素的<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/float" target="_blank" rel="noopener noreferrer"><code>float</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 不是 <code>none</code>）</li> <li>绝对定位元素（元素的<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/position" target="_blank" rel="noopener noreferrer"><code>position</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 为 <code>absolute</code> 或 <code>fixed</code>）</li> <li>行内块元素（元素的<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/display" target="_blank" rel="noopener noreferrer"><code>display</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 为 <code>inline-block</code>）</li> <li>表格单元格（元素的<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/display" target="_blank" rel="noopener noreferrer"><code>display</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 为 <code>table-cell</code>，HTML表格单元格默认为该值）</li> <li>表格标题（元素的<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/display" target="_blank" rel="noopener noreferrer"><code>display</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 为 <code>table-caption</code>，HTML表格标题默认为该值）</li> <li>匿名表格单元格元素（元素的<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/display" target="_blank" rel="noopener noreferrer"><code>display</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 为 <code>table&amp;#x3001;</code>table-row<code>、</code>table-row-group、<code>table-header-group&amp;#x3001;</code>table-footer-group``（分别是HTML table、row、tbody、thead、tfoot 的默认属性）或 <code>inline-table</code>）</li> <li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/overflow" target="_blank" rel="noopener noreferrer"><code>overflow</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 计算值(Computed)不为 <code>visible</code> 的块元素</li> <li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/display" target="_blank" rel="noopener noreferrer"><code>display</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 值为 <code>flow-root</code> 的元素</li> <li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/contain" target="_blank" rel="noopener noreferrer"><code>contain</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 值为 <code>layout</code>、 <code>content</code>或 paint 的元素</li> <li>弹性元素（<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/display" target="_blank" rel="noopener noreferrer"><code>display</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 为 <code>flex</code> 或 <code>inline-flex</code>元素的直接子元素）</li> <li>网格元素（<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/display" target="_blank" rel="noopener noreferrer"><code>display</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 为 <code>grid</code> 或 <code>inline-grid</code> 元素的直接子元素）</li> <li>多列容器（元素的<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/column-count" target="_blank" rel="noopener noreferrer"><code>column-count</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 或<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/column-width" target="_blank" rel="noopener noreferrer"><code>column-width</code> (en-US)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 不为 <code>auto&amp;#xFF0C;&amp;#x5305;&amp;#x62EC;</code>column-count`` 为 <code>1</code>）</li> <li><code>column-span</code> 为 <code>all</code> 的元素始终会创建一个新的BFC，即使该元素没有包裹在一个多列容器中（<a href="https://github.com/w3c/csswg-drafts/commit/a8634b96900279916bd6c505fda88dda71d8ec51" target="_blank" rel="noopener noreferrer">标准变更<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，<a href="https://bugs.chromium.org/p/chromium/issues/detail?id=709362" target="_blank" rel="noopener noreferrer">Chrome bug<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>）。</li></ul> <p>块格式化上下文包含创建它的元素内部的所有内容.</p> <p>块格式化上下文对浮动定位（参见 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/float" target="_blank" rel="noopener noreferrer"><code>float</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>）与清除浮动（参见 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/clear" target="_blank" rel="noopener noreferrer"><code>clear</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>）都很重要。浮动定位和清除浮动时只会应用于同一个BFC内的元素。浮动不会影响其它BFC中元素的布局，而清除浮动只能清除同一BFC中在它前面的元素的浮动。外边距折叠（<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Box_Model/Mastering_margin_collapsing" target="_blank" rel="noopener noreferrer">Margin collapsing<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>）也只会发生在属于同一BFC的块级元素之间。</p> <h2 id="_3-flex布局"><a href="#_3-flex布局" class="header-anchor">#</a> 3.flex布局</h2> <h3 id="什么是flex布局"><a href="#什么是flex布局" class="header-anchor">#</a> 什么是flex布局?</h3> <p><img src="https://img-blog.csdnimg.cn/img_convert/a63838edb4e83e2b468831efaa3cf508.png" alt=""></p> <p>顾名思义,flex布局就是弹性布局,在flex容器中默认存在两条轴， <strong>水平主轴(main axis) 和 垂直的交叉轴(cross axis)</strong>,我们可以通过设置属性将垂直方向变为主轴,水平方向变为交叉轴</p> <p>在容器内的每个单元块被称为 <strong>flex item</strong>,每个项目占据的主轴空间为(main size)，占据的交叉轴的空间为(cross size)</p> <h4 id="flex容器"><a href="#flex容器" class="header-anchor">#</a> flex容器</h4> <p>实现 flex 布局需要先指定一个容器，任何一个容器都可以被指定为 flex 布局，这样容器内部的元素就可以使用 flex 来进行布局。</p> <div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">.container</span> <span class="token punctuation">{</span>    <span class="token property">display</span><span class="token punctuation">:</span> flex | inline-flex<span class="token punctuation">;</span>       //可以有两种取值<span class="token punctuation">}</span>
</code></pre></div><p><strong>需要注意的是：当时设置 flex 布局之后，子元素的 float、clear、vertical-align 的属性将会失效。</strong></p> <p>有下面六种属性可以设置在容器上，它们分别是：</p> <ol><li>flex-direction</li> <li>flex-wrap</li> <li>flex-flow</li> <li>justify-content</li> <li>align-items</li> <li>align-content</li></ol> <p><strong>flex-direction</strong>:决定主轴的方向</p> <div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">.container</span> <span class="token punctuation">{</span>    <span class="token property">flex-direction</span><span class="token punctuation">:</span> row | row-reverse | column | column-reverse<span class="token punctuation">;</span><span class="token punctuation">}</span>
</code></pre></div><p><strong>row</strong>：默认值,主轴为水平方向,起点在左端</p> <p><strong>row-reverse</strong>:主轴为水平方向,起点在右端</p> <p><strong>column</strong>:主轴为垂直方向,起点在上沿</p> <p><strong>column-reverse</strong>：主轴为垂直方向,起点在下端</p> <p><strong>flex-wrap</strong>：决定容器内项目是否可以换行</p> <p>默认情况下，项目都排在主轴线上，使用 flex-wrap 可实现项目的换行。</p> <div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">.container</span> <span class="token punctuation">{</span>    <span class="token property">flex-wrap</span><span class="token punctuation">:</span> nowrap | wrap | wrap-reverse<span class="token punctuation">;</span><span class="token punctuation">}</span>
</code></pre></div><p><strong>nowrap</strong>: <strong>默认值</strong>，不换行,即当主轴尺寸固定时，当空间不足时，项目尺寸会随之调整而并不会挤到下一行。</p> <p><img src="https://img-blog.csdnimg.cn/img_convert/3c05db890dc2fac354eac91cac60c25a.png" alt=""></p> <p><strong>wrap</strong>：换行,当项目主轴总尺寸超过容器时换行,第一行在上方</p> <p><img src="https://img-blog.csdnimg.cn/img_convert/2c2f654a01a0adbc9fbb342fd9442aaa.png" alt=""></p> <p><strong>wrap-reverse</strong>:换行，第一行在下方</p> <p><img src="https://img-blog.csdnimg.cn/img_convert/af5b99e4920f8fbb846a52dacd2555fc.png" alt=""></p> <p><strong>flex-flow</strong>: <strong>flex-direction 和 flex-wrap 的简写形式</strong></p> <div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">.container</span> <span class="token punctuation">{</span>    <span class="token property">flex-flow</span><span class="token punctuation">:</span>  || <span class="token punctuation">;</span><span class="token punctuation">}</span>
</code></pre></div><p><strong>默认值</strong>为: row nowrap</p> <p><strong>justify-content：定义了项目在主轴的对齐方式。</strong></p> <div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">.container</span> <span class="token punctuation">{</span>    <span class="token property">justify-content</span><span class="token punctuation">:</span> flex-start | flex-end | center | space-between | space-around<span class="token punctuation">;</span><span class="token punctuation">}</span>
</code></pre></div><p>假设主轴是 <strong>水平方向</strong>,垂直方向同理(左右改为上下)</p> <p><strong>flex-start</strong>:左对齐</p> <p><strong>flex-end</strong>:右对齐</p> <p><strong>center</strong>：居中</p> <p><strong>space-between</strong>：两端对齐,项目之间的间隔相等，即剩余空间等分成间隙。</p> <p><strong>space-around</strong>：每个项目两侧的间隔相等，所以项目之间的间隔比项目与边缘的间隔大一倍。</p> <p><strong>align-items: 定义了项目在交叉轴上的对齐方式</strong></p> <div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">.container</span> <span class="token punctuation">{</span>    <span class="token property">align-items</span><span class="token punctuation">:</span> flex-start | flex-end | center | baseline | stretch<span class="token punctuation">;</span><span class="token punctuation">}</span>
</code></pre></div><p><strong>baseline</strong>:项目的第一行文字的基线对齐</p> <p><strong>stretch</strong>: <strong>默认值</strong> 即如果项目未设置高度或者设为 auto，将占满整个容器的高度</p> <p><strong>align-content: 定义了多根轴线的对齐方式，如果项目只有一根轴线，那么该属性将不起作用</strong></p> <div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">.container</span> <span class="token punctuation">{</span>    <span class="token property">align-content</span><span class="token punctuation">:</span> flex-start | flex-end | center | space-between | space-around | stretch<span class="token punctuation">;</span><span class="token punctuation">}</span>
</code></pre></div><p>当你 flex-wrap 设置为 <strong>nowrap</strong> 的时候，容器仅存在一根轴线，因为项目不会换行，就不会产生多条轴线。</p> <p>当你 flex-wrap 设置为 <strong>wrap</strong> 的时候，容器可能会出现多条轴线，这时候你就需要去设置多条轴线之间的对齐方式了。</p> <h4 id="flex元素属性"><a href="#flex元素属性" class="header-anchor">#</a> flex元素属性</h4> <p>有六种属性可运用在 item 项目上：</p> <ol><li>order</li> <li>flex-basis</li> <li>flex-grow</li> <li>flex-shrink</li> <li>flex</li> <li>align-self</li></ol> <p><strong>order: 定义项目在容器中的排列顺序，数值越小，排列越靠前，默认值为 0</strong></p> <div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">.item</span> <span class="token punctuation">{</span>    <span class="token property">order</span><span class="token punctuation">:</span> <span class="token punctuation">;</span><span class="token punctuation">}</span>
</code></pre></div><p><img src="https://img-blog.csdnimg.cn/img_convert/83827040cb8c91acb8ed52e72d122453.png" alt=""></p> <p><strong>flex-basis: 定义了在分配多余空间之前，项目占据的主轴空间，浏览器根据这个属性，计算主轴是否有多余空间</strong></p> <div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">.item</span> <span class="token punctuation">{</span>    <span class="token property">flex-basis</span><span class="token punctuation">:</span>  | auto<span class="token punctuation">;</span><span class="token punctuation">}</span>
</code></pre></div><p>默认值： <strong>auto</strong>，即项目本来的大小, 这时候 item 的宽高取决于 width 或 height 的值。</p> <p><strong>当主轴为水平方向的时候，当设置了 flex-basis，项目的宽度设置值会失效，flex-basis 需要跟 flex-grow 和 flex-shrink 配合使用才能发挥效果。</strong></p> <ul><li>当 flex-basis 值为 0 % 时，是把该项目视为零尺寸的，故即使声明该尺寸为 140px，也并没有什么用。</li> <li>当 flex-basis 值为 auto 时，则跟根据尺寸的设定值(假如为 100px)，则这 100px 不会纳入剩余空间。</li></ul> <p><strong>flex-grow: 定义项目的放大比例</strong></p> <div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">.item</span> <span class="token punctuation">{</span>    <span class="token property">flex-grow</span><span class="token punctuation">:</span> <span class="token punctuation">;</span><span class="token punctuation">}</span>
</code></pre></div><p><strong>默认值为 0，即如果存在剩余空间，也不放大</strong></p> <p><img src="https://img-blog.csdnimg.cn/img_convert/29bd6490e9a4f3752e529cc1df7550cd.png" alt=""></p> <p>当所有的项目都以 flex-basis 的值进行排列后，仍有剩余空间，那么这时候 flex-grow 就会发挥作用了。</p> <p>如果所有项目的 flex-grow 属性都为 1，则它们将等分剩余空间。(如果有的话)</p> <p>如果一个项目的 flex-grow 属性为 2，其他项目都为 1，则前者占据的剩余空间将比其他项多一倍。</p> <p>当然如果当所有项目以 flex-basis 的值排列完后发现空间不够了，且 flex-wrap：nowrap 时，此时 flex-grow 则不起作用了，这时候就需要接下来的这个属性。</p> <p><strong>flex-shrink: 定义了项目的缩小比例</strong></p> <div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">.item</span> <span class="token punctuation">{</span>    <span class="token property">flex-shrink</span><span class="token punctuation">:</span> <span class="token punctuation">;</span><span class="token punctuation">}</span>
</code></pre></div><p><strong>默认值: 1，即如果空间不足，该项目将缩小，负值对该属性无效。</strong></p> <p><img src="https://img-blog.csdnimg.cn/img_convert/969ce79f491cb168189189b50d356805.png" alt=""></p> <p>这里可以看出，虽然每个项目都设置了宽度为 50px，但是由于自身容器宽度只有 200px，这时候每个项目会被同比例进行缩小，因为默认值为 1。</p> <p>同理可得：</p> <p>如果所有项目的 flex-shrink 属性都为 1，当空间不足时，都将等比例缩小。</p> <p>如果一个项目的 flex-shrink 属性为 0，其他项目都为 1，则空间不足时，前者不缩小。</p> <p><strong>flex: flex-grow, flex-shrink 和 flex-basis的简写</strong></p> <p>flex 的默认值是以上三个属性值的组合。假设以上三个属性同样取默认值，则 <strong>flex 的默认值是 0 1 auto</strong>。</p> <p>grow 和 shrink 是一对双胞胎，grow 表示伸张因子，shrink 表示是收缩因子。</p> <p>grow 在 flex 容器下的子元素的宽度和比容器和小的时候起作用。 grow 定义了子元素的尺寸增长因子，容器中除去子元素之和剩下的尺寸会按照各个子元素的 grow 值进行平分加大各个子元素上。</p> <p><strong>lign-self: 允许单个项目有与其他项目不一样的对齐方式</strong></p> <p>单个项目覆盖 align-items 定义的属性</p> <p>默认值为 auto，表示继承父元素的 align-items 属性，如果没有父元素，则等同于 stretch。</p> <div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">.item</span> <span class="token punctuation">{</span>
     <span class="token property">align-self</span><span class="token punctuation">:</span> auto | flex-start | flex-end | center | baseline | stretch<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这个跟 align-items 属性时一样的，只不过 align-self 是对单个项目生效的，而 align-items 则是对容器下的所有项目生效的。</p> <p><img src="https://img-blog.csdnimg.cn/img_convert/d59dbc22dba4c9df9f70879ed866ef73.png" alt=""></p> <p><a href="https://codepen.io/pen/" target="_blank" rel="noopener noreferrer">A Pen by 张振明 (codepen.io)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h3 id="如何用flex实现九宫格布局"><a href="#如何用flex实现九宫格布局" class="header-anchor">#</a> 如何用flex实现九宫格布局</h3> <p><a href="https://codepen.io/zhangzhenming20020615/pen/YzYXqWj" target="_blank" rel="noopener noreferrer">flex实现九宫格布局 (codepen.io)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h3 id="flex-1指的是什么-flex属性默认值是什么"><a href="#flex-1指的是什么-flex属性默认值是什么" class="header-anchor">#</a> flex:1指的是什么？flex属性默认值是什么</h3> <p><code>flex:1</code> 为： <code>flex: 1 1 0</code>;</p> <p>flex属性默认值为: <code>0 1 auto</code></p> <p>具体代表什么属性 上文有说明</p> <h3 id="介绍一下flex-shrink和flex-basis属性"><a href="#介绍一下flex-shrink和flex-basis属性" class="header-anchor">#</a> 介绍一下flex-shrink和flex-basis属性</h3> <h2 id="_4-1px问题"><a href="#_4-1px问题" class="header-anchor">#</a> 4.1px问题</h2> <h2 id="_5-重绘与回流"><a href="#_5-重绘与回流" class="header-anchor">#</a> 5.重绘与回流</h2> <p>参考:[浏览器的重绘和回流](<a href="https://juejin.cn/post/6844903569087266823" target="_blank" rel="noopener noreferrer">浏览器的回流与重绘 (Reflow &amp; Repaint) - 掘金 (juejin.cn)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>)</p> <p>在讨论回流与重绘之前，我们要知道：</p> <ol><li>浏览器使用流式布局模型 (Flow Based Layout)。</li> <li>浏览器会把 <code>HTML</code>解析成 <code>DOM</code>，把 <code>CSS</code>解析成 <code>CSSOM</code>， <code>DOM</code>和 <code>CSSOM</code>合并就产生了 <code>Render Tree</code>。</li> <li>有了 <code>RenderTree</code>，我们就知道了所有节点的样式，然后计算他们在页面上的大小和位置，最后把节点绘制到页面上。</li> <li>由于浏览器使用流式布局，对 <code>Render Tree</code>的计算通常只需要遍历一次就可以完成，但 <code>table</code>及其内部元素除外，他们可能需要多次计算，通常要花3倍于同等元素的时间，这也是为什么要避免使用 <code>table</code>布局的原因之一。</li></ol> <p><strong>一句话：回流必将引起重绘，重绘不一定会引起回流。</strong></p> <h3 id="_1-回流-reflow"><a href="#_1-回流-reflow" class="header-anchor">#</a> 1.回流 (Reflow)</h3> <p>当 <code>Render Tree</code>中部分或全部元素的尺寸、结构、或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程称为回流。</p> <p>会导致回流的操作：</p> <ul><li>页面首次渲染</li> <li>浏览器窗口大小发生改变</li> <li>元素尺寸或位置发生改变</li> <li>元素内容变化（文字数量或图片大小等等）</li> <li>元素字体大小变化</li> <li>添加或者删除 <strong>可见</strong>的 <code>DOM</code>元素</li> <li>激活 <code>CSS</code>伪类（例如： <code>:hover</code>）</li> <li>查询某些属性或调用某些方法</li></ul> <p>一些常用且会导致回流的属性和方法：</p> <ul><li><code>clientWidth</code>、 <code>clientHeight</code>、 <code>clientTop</code>、 <code>clientLeft</code></li> <li><code>offsetWidth</code>、 <code>offsetHeight</code>、 <code>offsetTop</code>、 <code>offsetLeft</code></li> <li><code>scrollWidth</code>、 <code>scrollHeight</code>、 <code>scrollTop</code>、 <code>scrollLeft</code></li> <li><code>scrollIntoView()</code>、 <code>scrollIntoViewIfNeeded()</code></li> <li><code>getComputedStyle()</code></li> <li><code>getBoundingClientRect()</code></li> <li><code>scrollTo()</code></li></ul> <h4 id="_2-重绘-repaint"><a href="#_2-重绘-repaint" class="header-anchor">#</a> 2.重绘 (Repaint)</h4> <p>当页面中元素样式的改变并不影响它在文档流中的位置时（例如： <code>color</code>、 <code>background-color</code>、 <code>visibility</code>等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。</p> <h3 id="_3-性能影响"><a href="#_3-性能影响" class="header-anchor">#</a> 3.性能影响</h3> <p><strong>回流比重绘的代价要更高。</strong></p> <p>有时即使仅仅回流一个单一的元素，它的父元素以及任何跟随它的元素也会产生回流。</p> <p>现代浏览器会对频繁的回流或重绘操作进行优化：</p> <p>浏览器会维护一个队列，把所有引起回流和重绘的操作放入队列中，如果队列中的任务数量或者时间间隔达到一个阈值的，浏览器就会将队列清空，进行一次批处理，这样可以把多次回流和重绘变成一次。</p> <p>当你访问以下属性或方法时，浏览器会立刻清空队列：</p> <ul><li><code>clientWidth</code>、 <code>clientHeight</code>、 <code>clientTop</code>、 <code>clientLeft</code></li> <li><code>offsetWidth</code>、 <code>offsetHeight</code>、 <code>offsetTop</code>、 <code>offsetLeft</code></li> <li><code>scrollWidth</code>、 <code>scrollHeight</code>、 <code>scrollTop</code>、 <code>scrollLeft</code></li> <li><code>width</code>、 <code>height</code></li> <li><code>getComputedStyle()</code></li> <li><code>getBoundingClientRect()</code></li></ul> <p>因为队列中可能会有影响到这些属性或方法返回值的操作，即使你希望获取的信息与队列中操作引发的改变无关，浏览器也会强行清空队列，确保你拿到的值是最精确的。</p> <h3 id="_4-如何避免"><a href="#_4-如何避免" class="header-anchor">#</a> 4.如何避免</h3> <h4 id="_1-css"><a href="#_1-css" class="header-anchor">#</a> 1.CSS</h4> <ul><li>避免使用 <code>table</code>布局。</li> <li>尽可能在 <code>DOM</code>树的最末端改变 <code>class</code>。</li> <li>避免设置多层内联样式。</li> <li>将动画效果应用到 <code>position</code>属性为 <code>absolute</code>或 <code>fixed</code>的元素上。</li> <li>避免使用 <code>CSS</code>表达式（例如： <code>calc()</code>）。</li></ul> <h4 id="_2-javascript"><a href="#_2-javascript" class="header-anchor">#</a> 2.JavaScript</h4> <ul><li>避免频繁操作样式，最好一次性重写 <code>style</code>属性，或者将样式列表定义为 <code>class</code>并一次性更改 <code>class</code>属性。</li> <li>避免频繁操作 <code>DOM</code>，创建一个 <code>documentFragment</code>，在它上面应用所有 <code>DOM&amp;#x64CD;&amp;#x4F5C;</code>，最后再把它添加到文档中。</li> <li>也可以先为元素设置 <code>display: none</code>，操作结束后再把它显示出来。因为在 <code>display</code>属性为 <code>none</code>的元素上进行的 <code>DOM</code>操作不会引发回流和重绘。</li> <li>避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。</li> <li>对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。</li></ul> <p><strong>总结</strong>:会引起元素位置变化的就会reflow，如博主上面介绍的，窗口大小改变、字体大小改变、以及元素位置改变，都会引起周围的元素改变他们以前的位置；不会引起位置变化的，只是在以前的位置进行改变背景颜色等，只会repaint；</p> <h2 id="_6-居中布局"><a href="#_6-居中布局" class="header-anchor">#</a> 6.居中布局</h2> <h2 id="_7-层叠上下文"><a href="#_7-层叠上下文" class="header-anchor">#</a> 7.层叠上下文</h2> <blockquote><p>参考:<a href="https://juejin.cn/post/6844903667175260174#heading-1" target="_blank" rel="noopener noreferrer">彻底搞懂CSS层叠上下文、层叠等级、层叠顺序、z-index - 掘金 (juejin.cn)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <p>首先， <code>z-index</code>属性值并不是在任何元素上都有效果。它 <strong>仅在</strong>定位元素（定义了 <code>position</code>属性，且属性值为非 <code>static</code>值的元素）上有效果。</p> <p>判断元素在 <code>Z&amp;#x8F74;</code>上的堆叠顺序，不仅仅是直接比较两个元素的 <code>z-index</code>值的大小，这个堆叠顺序实际由元素的 <strong>层叠上下文</strong>、 <strong>层叠等级</strong>共同决定。</p> <p><img src="https://img-blog.csdnimg.cn/img_convert/5a4729d2507ff92d56559d36b69f174e.png" alt=""></p> <h3 id="_1-什么是层叠上下文"><a href="#_1-什么是层叠上下文" class="header-anchor">#</a> 1.什么是层叠上下文</h3> <p>层叠上下文(stacking context)，是HTML中一个三维的概念。在CSS2.1规范中，每个盒模型的位置是三维的，分别是平面画布上的 <code>X&amp;#x8F74;</code>， <code>Y&amp;#x8F74;</code>以及表示层叠的 <code>Z&amp;#x8F74;</code>。一般情况下，元素在页面上沿 <code>X&amp;#x8F74;Y&amp;#x8F74;</code>平铺，我们察觉不到它们在 <code>Z&amp;#x8F74;</code>上的层叠关系。而一旦元素发生堆叠，这时就能发现某个元素可能覆盖了另一个元素或者被另一个元素覆盖。</p> <p>如果一个元素含有层叠上下文，(也就是说它是层叠上下文元素)，我们可以理解为这个元素在 <code>Z&amp;#x8F74;</code>上就&quot;高人一等&quot;，最终表现就是它离屏幕观察者更近。</p> <blockquote><p><strong>具象的比喻</strong>：你可以把层叠上下文元素理解为理解为 <strong>该元素当了官</strong>，而其他非层叠上下文元素则可以理解为普通群众。凡是&quot;当了官的元素&quot;就比普通元素等级要高，也就是说元素在 <code>Z&amp;#x8F74;</code>上更靠上，更靠近观察者。</p></blockquote> <h3 id="_2-什么是层叠等级"><a href="#_2-什么是层叠等级" class="header-anchor">#</a> 2.什么是层叠等级</h3> <p>那么，层叠等级指的又是什么？层叠等级(stacking level，叫&quot;层叠级别&quot;/&quot;层叠水平&quot;也行)</p> <ul><li>在同一个层叠上下文中，它描述定义的是该层叠上下文中的层叠上下文元素在 <code>Z&amp;#x8F74;</code>上的上下顺序。</li> <li>在其他普通元素中，它描述定义的是这些普通元素在 <code>Z&amp;#x8F74;</code>上的上下顺序。</li></ul> <p>说到这，可能很多人疑问了，不论在层叠上下文中还是在普通元素中，层叠等级都表示元素在 <code>Z&amp;#x8F74;</code>上的上下顺序，那就直接说它描述定义了所有元素在 <code>Z&amp;#x8F74;</code>上的上下顺序就OK啊！为什么要分开描述？</p> <p>为了说明原因，先举个栗子：</p> <blockquote><p><strong>具象的比喻</strong>：我们之前说到，处于层叠上下文中的元素，就像是元素当了官，等级自然比普通元素高。再想象一下，假设一个官员A是个省级领导，他下属有一个秘书a-1，家里有一个保姆a-2。另一个官员B是一个县级领导，他下属有一个秘书b-1，家里有一个保姆b-2。a-1和b-1虽然都是秘书，但是你想一个省级领导的秘书和一个县级领导的秘书之间有可比性么？甚至保姆a-2都要比秘书b-1的等级高得多。谁大谁小，谁高谁低一目了然，所以根本没有比较的意义。只有在A下属的a-1、a-2以及B下属的b-1、b-2中相互比较大小高低才有意义。</p></blockquote> <p><strong>再类比回&quot;层叠上下文&quot;和&quot;层叠等级&quot;，就得出一个结论：</strong></p> <ol><li>普通元素的层叠等级优先由其所在的层叠上下文决定。</li> <li>层叠等级的比较只有在当前层叠上下文元素中才有意义。不同层叠上下文中比较层叠等级是没有意义的。</li></ol> <h3 id="_3-如何产生-层叠上下文"><a href="#_3-如何产生-层叠上下文" class="header-anchor">#</a> 3.如何产生&quot;层叠上下文&quot;</h3> <p>前面说了那么多，知道了&quot;层叠上下文&quot;和&quot;层叠等级&quot;，其中还有一个最关键的问题：到底如何产生层叠上下文呢？如何让一个元素变成层叠上下文元素呢？</p> <p>其实，层叠上下文也基本上是有一些特定的CSS属性创建的，一般有3种方法：</p> <ol><li><code>HTML</code>中的根元素 <code>&lt;html&gt;&lt;/html&gt;</code>本身j就具有层叠上下文，称为&quot;根层叠上下文&quot;。</li> <li>普通元素设置 <code>position</code>属性为 <strong>非</strong> <code>static</code>值并设置 <code>z-index</code>属性为具体数值，产生层叠上下文。</li> <li>CSS3中的新属性也可以产生层叠上下文。</li></ol> <p>上面说了那么多，可能你还是有点懵。这么多概念规则，来点最实际的，有没有一个&quot;套路&quot;当遇到元素层叠时，能很清晰地判断出他们谁在上谁在下呢？答案是——肯定有啊！</p> <ol><li>首先先看要比较的两个元素是否处于同一个层叠上下文中</li> <li>如果是，谁的层叠等级大，谁在上面</li> <li>如果两个元素不在统一层叠上下文中，请先比较他们所处的层叠上下文的层叠等级</li> <li>当两个元素层叠等级相同、层叠顺序相同时，在DOM结构中后面的元素层叠等级在前面元素之上</li></ol> <h2 id="_8-sass-less"><a href="#_8-sass-less" class="header-anchor">#</a> 8.sass/less</h2> <h3 id="_3-vue"><a href="#_3-vue" class="header-anchor">#</a> 3.Vue</h3> <p><img src="https://img-blog.csdnimg.cn/img_convert/0716bd1cd2bcd746532647397b37462d.webp?x-oss-process=image/format,png" alt=""></p> <h2 id="_1-mvvm"><a href="#_1-mvvm" class="header-anchor">#</a> 1.MVVM</h2> <h3 id="_1-什么是mvvm"><a href="#_1-什么是mvvm" class="header-anchor">#</a> 1.什么是MVVM?</h3> <blockquote><p>Model–View–ViewModel （MVVM） 是一个软件架构设计模式，源于经典的Model-View-Controller(MVC)模式,MVVM 的出现促进了前端开发与后端业务逻辑的分离，极大地提高了前端开发效率.</p></blockquote> <p><img src="https://img-blog.csdnimg.cn/img_convert/b2986ec7503acdc01b7dd04078781e30.webp?x-oss-process=image/format,png" alt=""></p> <p><strong>MVVM</strong>的核心是 <strong>ViewModel</strong>层,它就像是一个中转站（value converter），负责转换 Model 中的数据对象来让数据变得更容易管理和使用， <strong>该层向上与视图层进行双向数据绑定，向下与 Model 层通过接口请求进行数据交互</strong>，起呈上启下作用。</p> <p><strong>View层</strong></p> <p>View 是视图层，也就是用户界面。前端主要由 HTML 和 CSS 来构建 。</p> <p><strong>Model 层</strong></p> <p>Model 是指数据模型，泛指后端进行的各种业务逻辑处理和数据操控，对于前端来说就是后端提供的 api 接口。</p> <p><strong>ViewModel 层</strong></p> <p>** <code>ViewModel</code> 是由前端开发人员组织生成和维护的视图数据层**。在这一层，前端开发者对从后端获取的 Model 数据进行转换处理，做二次封装，以生成符合 View 层使用预期的视图数据模型。</p> <h2 id="_2-viewmodel有什么好处"><a href="#_2-viewmodel有什么好处" class="header-anchor">#</a> 2.ViewModel有什么好处?</h2> <p>MVVM 框架实现了双向绑定，这样 ViewModel 的内容会实时展现在 View 层，前端开发者再也不必低效又麻烦地通过操纵 DOM 去更新视图，MVVM 框架已经把最脏最累的一块做好了，我们开发者只需要处理和维护 ViewModel，更新数据视图就会自动得到相应更新。这样 View 层展现的不是 Model 层的数据，而是 ViewModel 的数据，由 ViewModel 负责与 Model 层交互，这就完全解耦了 View 层和 Model 层，这个解耦是至关重要的，它是前后端分离方案实施的重要一环。</p> <h2 id="_2-生命周期"><a href="#_2-生命周期" class="header-anchor">#</a> 2.生命周期</h2> <h3 id="_1-介绍一下vue生命周期"><a href="#_1-介绍一下vue生命周期" class="header-anchor">#</a> 1.介绍一下Vue生命周期</h3> <p><img src="https://img-blog.csdnimg.cn/img_convert/5ae436e45e4a1d25db3ea972323a6275.webp?x-oss-process=image/format,png" alt=""></p> <p>Vue 实例有一个完整的生命周期，也就是从开始创建实例、初始化数据、编译模版、挂载 Dom -&gt; 渲染、更新 -&gt; 渲染、卸载等一系列过程，我们称这是 Vue 的生命周期。</p> <p><strong>各个生命周期的作用</strong></p> <p>生命周期描述beforeCreate组件实例被创建之初，组件的属性生效之前created组件实例已经完全创建，属性也绑定，但真实 dom 还没有生成，$el 还不可用beforeMount在挂载开始之前被调用：相关的 render 函数首次被调用mountedel 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子beforeUpdate组件数据更新之前调用，发生在虚拟 DOM 打补丁之前updated组件数据更新之后activitedkeep-alive 专属，组件被激活时调用deactivatedkeep-alive 专属，组件被销毁时调用beforeDestory组件销毁前调用destoryed组件销毁后调用</p> <p><strong>beforeCreate</strong>:此时生命周期以及事件已经被初始化但是数据代理还未开始，无法通过vm访问到data中的数据、methods中的方法</p> <p><strong>created</strong>：此时数据监测和数据代理已经初始化，可以通过访问vm访问到data中的数据</p> <p><strong>beforeMount</strong>：此阶段Vue开始解析模板，生成虚拟DOM(内存中)，但是页面还不能显示解析好的内容，</p> <p>此时页面呈现的时未经Vue编译的DOM结构，所有对DOM的操作，最终都不奏效</p> <p><strong>mouted</strong>:此阶段内存中的虚拟DOM已经转成真实DOM插入页面。页面中呈现的时经过Vue编译的DOM，此时对DOM的操作均有效。至此初始化过程结束，一般再次进行:开启定时器、发送网络请求、订阅消息、绑定自定义事件等初始化操作、</p> <p><strong>beforeUpdate</strong>:此时数据是新的，但是页面是旧的，页面尚未和数据保持同步</p> <p><strong>updated</strong>:此时页面已经完成了从Model到View的更新，页面数据是新的，页面也是新的，即页面和数据保持同步</p> <p><strong>beforeDestory</strong>：此时vm中所有的data、methods、指令等等都处于可用状态，但是马上要执行销毁过程，一般在此阶段:关闭定时器，取消订阅消息、解绑自定义事件等收尾操作</p> <p><strong>destoryed</strong>:销毁vm实例</p> <h3 id="_2-nexttick是如何实现的"><a href="#_2-nexttick是如何实现的" class="header-anchor">#</a> 2.nextTick是如何实现的</h3> <p><strong>什么是nextTick?</strong></p> <blockquote><p>nextTick 是在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后使用nextTick，则可以在回调中获取更新后的 DOM</p></blockquote> <p><strong>nextTick原理</strong></p> <h3 id="_3-父子组件挂载时-生命周期的顺序是怎么样的"><a href="#_3-父子组件挂载时-生命周期的顺序是怎么样的" class="header-anchor">#</a> 3.父子组件挂载时,生命周期的顺序是怎么样的</h3> <p>vue 的父组件和子组件生命周期钩子函数执行顺序可以归类为以下 4 部分：</p> <ul><li>加载渲染过程 父 beforeCreate -&gt; 父 created -&gt; 父 beforeMount -&gt; 子 beforeCreate -&gt; 子 created -&gt; 子 beforeMount -&gt; 子 mounted -&gt; 父 mounted</li> <li>子组件更新过程 父 beforeUpdate -&gt; 子 beforeUpdate -&gt; 子 updated -&gt; 父 updated</li> <li>父组件更新过程 父 beforeUpdate -&gt; 父 updated</li> <li>销毁过程 父 beforeDestroy -&gt; 子 beforeDestroy -&gt; 子 destroyed -&gt; 父 destroyed</li></ul> <h2 id="_3-数据绑定"><a href="#_3-数据绑定" class="header-anchor">#</a> 3.数据绑定</h2> <h3 id="_1-vue的双向绑定如何实现"><a href="#_1-vue的双向绑定如何实现" class="header-anchor">#</a> 1.Vue的双向绑定如何实现</h3> <p>vue.js 是采用 <strong>数据劫持</strong>结合 <strong>发布者-订阅者模式</strong>的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。主要分为以下几个步骤：</p> <blockquote><p>1、需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上setter和getter这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化</p></blockquote> <blockquote><p>2、compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图</p></blockquote> <blockquote><p>3、Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是: ①在自身实例化时往属性订阅器(dep)里面添加自己 ②自身必须有一个update()方法 ③待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。</p></blockquote> <blockquote><p>4、MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据model变更的双向绑定效果。</p></blockquote> <p>按我自己的理解就是:当修改数据时,vue会调用dep.notify通知相应的wathcer执行它的update函数,update函数会执行compile中绑定的回调,然会修改dom的值.当修改视图层的数据时,vue通过监听input来获取input中的值并将其赋值给data中的对应属性，修改属性又会触发setter，于是又会执行dep.notify等一系列操作,从而达到双向绑定.</p> <h3 id="_2-vue如何监听数组或对象的改变"><a href="#_2-vue如何监听数组或对象的改变" class="header-anchor">#</a> 2.Vue如何监听数组或对象的改变</h3> <p><strong>1.vue会监视data中所有层次的数据</strong></p> <p><strong>2.如何监测对象中的数据？</strong></p> <p>​ 通过setter事件监视，且要在newVue时就传入要监测的数据</p> <p>​ (1).在对象后追加的属性，Vue默认不做响应式处理</p> <p>​ (2).如需给后添加的属性做响应式，需要使用以下API:</p> <p>​ Vue.set(target,propertyName/index,value)</p> <p>​ vm.$set(target,propertyName/index,value)</p> <p><strong>3.如何监测数组中的数据?</strong></p> <p>​ 通过包裹数组更新元素的方法实现，本质就是做了两件事:</p> <p>​ (1).调用原生对应的方法对数组进行更新</p> <p>​ (2).重新解析模板，进而更新页面</p> <p><strong>4.在Vue修改数组中的某个元素需要用到以下方法:</strong></p> <p>​ 1.使用这些API:push(),pop(),shift(),unshift(),splice(),sort(),erverse()</p> <p>​ 2.Vue.set()或vm.$set</p> <h3 id="_3-defineproperty和proxy的区别"><a href="#_3-defineproperty和proxy的区别" class="header-anchor">#</a> 3.defineProperty和proxy的区别</h3> <p><strong>Proxy 的优势如下:</strong></p> <ul><li>Proxy 可以直接监听对象而非属性；</li> <li>Proxy 可以直接监听数组的变化；</li> <li>Proxy 有多达 13 种拦截方法,不限于 apply、ownKeys、deleteProperty、has 等等是 Object.defineProperty 不具备的；</li> <li>Proxy 返回的是一个新对象,我们可以只操作新的对象达到目的,而 Object.defineProperty 只能遍历对象属性直接修改；</li> <li>Proxy 作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利；</li></ul> <p><strong>Object.defineProperty 的优势如下:</strong></p> <ul><li>兼容性好，支持 IE9，而 Proxy 的存在浏览器兼容性问题,而且无法用 polyfill 磨平</li></ul> <h3 id="_4-vue中的数据为什么频繁变化但只会更新一次"><a href="#_4-vue中的数据为什么频繁变化但只会更新一次" class="header-anchor">#</a> 4.Vue中的数据为什么频繁变化但只会更新一次</h3> <h2 id="_4-状态管理"><a href="#_4-状态管理" class="header-anchor">#</a> 4.状态管理</h2> <h3 id="_1-vuex是什么"><a href="#_1-vuex是什么" class="header-anchor">#</a> 1.vuex是什么</h3> <blockquote><p>专门在Vue中实现集中式状态(数据)管理的一个Vue插件，对vue应用中多个组件的共享状态进行集中式的管理(读/写),也是一种组件间通信的方式，且适用于任意组件间通信</p></blockquote> <ul><li>Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</li> <li>改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化。</li></ul> <h3 id="_2-什么时候使用vuex"><a href="#_2-什么时候使用vuex" class="header-anchor">#</a> 2.什么时候使用vuex?</h3> <ul><li>​ 多个组件依赖同一状态</li> <li>​ 来自不同组件的行为需要变更同一状态</li></ul> <h3 id="_3-vuex的工作原理"><a href="#_3-vuex的工作原理" class="header-anchor">#</a> 3.vuex的工作原理</h3> <p><img src="https://img-blog.csdnimg.cn/img_convert/cd34f70f7077fb6e1e2201571e5197fd.png" alt=""></p> <p>vuex包括以下几个模块:</p> <ul><li><strong>State</strong>：定义了应用状态的数据结构，可以在这里设置默认的初始状态。 1.vuex管理的状态对象(存放数据的对象) 2.它应该时唯一的 3.示例代码:</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token punctuation">{</span>

<span class="token punctuation">}</span>
</code></pre></div><ul><li><strong>Getter</strong>：允许组件从 Store 中获取数据，mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性。 当state中的数据需要经过加工后再使用时，可以使用getters加工,类似于组件中的计算属性</li> <li><strong>Mutation</strong>：是唯一更改 store 中状态的方法，且必须是同步函数。 1.值是一个对象，包含多个直接更新state的方法 2.谁能调用mutations中的方法？如何让调用？ ​ 在action中使用:**commit('对应的mutations方法名')**触发 3.mutations中方法的特点：不能写异步代码、只能单纯的操作state 4.示例代码:</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> mutations <span class="token operator">=</span> <span class="token punctuation">{</span>

<span class="token punctuation">}</span>
</code></pre></div><ul><li><strong>Action</strong>：用于提交 mutation，而不是直接变更状态，可以包含任意异步操作。 1.值为一个对象，包含多个响应用户动作的回调函数 2.通过commit()来触发mutation中函数的调用，间接更新state 3.示例代码:</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> actions <span class="token operator">=</span> <span class="token punctuation">{</span>

<span class="token punctuation">}</span>
</code></pre></div><ul><li><strong>Module</strong>：允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中。</li></ul> <h3 id="_4-vuex中4个map方法的使用"><a href="#_4-vuex中4个map方法的使用" class="header-anchor">#</a> 4. <strong>vuex中4个map方法的使用</strong></h3> <p>定义:使用vuex提供的map方法可以对组件中的计算属性和方法进行映射，可以大大的减少代码量，提高代码的复用率</p> <h4 id="_1-mapstate"><a href="#_1-mapstate" class="header-anchor">#</a> 1.mapState</h4> <p>理解:用于帮助我们映射state中的数据为计算属性</p> <div class="language-js extra-class"><pre class="language-js"><code> <span class="token literal-property property">computed</span><span class="token operator">:</span><span class="token punctuation">{</span>

      <span class="token operator">...</span><span class="token function">mapState</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token literal-property property">count</span><span class="token operator">:</span><span class="token string">'count'</span><span class="token punctuation">,</span><span class="token literal-property property">student</span><span class="token operator">:</span><span class="token string">'student'</span><span class="token punctuation">,</span><span class="token literal-property property">school</span><span class="token operator">:</span><span class="token string">'school'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>

      <span class="token operator">...</span><span class="token function">mapState</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'count'</span><span class="token punctuation">,</span><span class="token string">'student'</span><span class="token punctuation">,</span><span class="token string">'school'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
</code></pre></div><h4 id="_2-mapgetters"><a href="#_2-mapgetters" class="header-anchor">#</a> 2.mapGetters</h4> <p>理解:用于帮助我们映射getters中的数据为计算属性</p> <div class="language-js extra-class"><pre class="language-js"><code> <span class="token literal-property property">computed</span><span class="token operator">:</span><span class="token punctuation">{</span>

      <span class="token operator">...</span><span class="token function">mapState</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token literal-property property">count</span><span class="token operator">:</span><span class="token string">'count'</span><span class="token punctuation">,</span><span class="token literal-property property">student</span><span class="token operator">:</span><span class="token string">'student'</span><span class="token punctuation">,</span><span class="token literal-property property">school</span><span class="token operator">:</span><span class="token string">'school'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>

      <span class="token operator">...</span><span class="token function">mapGetters</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'bigCount'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
</code></pre></div><h4 id="_3-mapactions"><a href="#_3-mapactions" class="header-anchor">#</a> 3.mapActions</h4> <p>理解:用于帮助我们生成与action对话的方法，即：包含$store.dispatch(xxx)的函数</p> <div class="language-js extra-class"><pre class="language-js"><code>   <span class="token literal-property property">methods</span><span class="token operator">:</span><span class="token punctuation">{</span>

     <span class="token operator">...</span><span class="token function">mapActions</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token literal-property property">addOdd</span><span class="token operator">:</span><span class="token string">'addOdd'</span><span class="token punctuation">,</span><span class="token literal-property property">addWait</span><span class="token operator">:</span><span class="token string">'addWait'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>

      <span class="token operator">...</span><span class="token function">mapActions</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'addOdd'</span><span class="token punctuation">,</span><span class="token string">'addWait'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
</code></pre></div><h4 id="_4-mapmutations"><a href="#_4-mapmutations" class="header-anchor">#</a> 4.mapMutations</h4> <p>理解：用于帮助我们生成与mutations对话的方法，即：包含$store.commit(xxx)的函数</p> <div class="language-js extra-class"><pre class="language-js"><code>  <span class="token literal-property property">methods</span><span class="token operator">:</span><span class="token punctuation">{</span>

     <span class="token operator">...</span><span class="token function">mapMutations</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token literal-property property">add</span><span class="token operator">:</span><span class="token string">'Add'</span><span class="token punctuation">,</span><span class="token literal-property property">reduce</span><span class="token operator">:</span><span class="token string">'Reduce'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>

      <span class="token operator">...</span><span class="token function">mapActions</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'Add'</span><span class="token punctuation">,</span><span class="token string">'Reduce'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
</code></pre></div><p>注意:当我们使用 <strong>mapActions</strong>和 <strong>mapMutations</strong>方法时，我们需要将dispatch和commit中需要传递的值通过组件中方法传参，例如:</p> <div class="language-html extra-class"><pre class="language-html"><code> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>add(n)<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>+button&gt;
</code></pre></div><h3 id="_5-vuex的基本使用"><a href="#_5-vuex的基本使用" class="header-anchor">#</a> 5.vuex的基本使用</h3> <p>案例:点击按钮对数字进行各种操作</p> <p><img src="https://img-blog.csdnimg.cn/img_convert/0b7a7bfb463737fa44fe6d118486e5f5.png" alt=""></p> <p>我们将求和之后的数字定义为count，存入vuex的临时组件中，每次进行操作从原组件中调用vuex的api，最终完成求和的计算</p> <p>Count.vue组件:</p> <div class="language-html extra-class"><pre class="language-html"><code>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token punctuation">&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">&gt;</span></span>当前求和为:{{$store.state.count}}h1&gt;
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">v-model.number</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>n<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>option</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>1<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>1option&gt;
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>option</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>2<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>2option&gt;
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>option</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>3<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>3option&gt;
      select&gt;
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>add<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>+button&gt;
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>reduce<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>-button&gt;
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>addOdd<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>当前求和为奇数再加button&gt;
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>addWait<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>等一等再加button&gt;
  div&gt;
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
    <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token keyword">return</span><span class="token punctuation">{</span>
       <span class="token literal-property property">n</span><span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">,</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token literal-property property">methods</span><span class="token operator">:</span><span class="token punctuation">{</span>
      <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">'Add'</span><span class="token punctuation">,</span><span class="token keyword">this</span><span class="token punctuation">.</span>n<span class="token punctuation">)</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
      <span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">'Reduce'</span><span class="token punctuation">,</span><span class="token keyword">this</span><span class="token punctuation">.</span>n<span class="token punctuation">)</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
      <span class="token function">addOdd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span><span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token string">'addOdd'</span><span class="token punctuation">,</span><span class="token keyword">this</span><span class="token punctuation">.</span>n<span class="token punctuation">)</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
      <span class="token function">addWait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
           <span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span><span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token string">'addWait'</span><span class="token punctuation">,</span><span class="token keyword">this</span><span class="token punctuation">.</span>n<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>store中index.js</p> <div class="language-js extra-class"><pre class="language-js"><code>
<span class="token keyword">import</span> Vue <span class="token keyword">from</span> <span class="token string">'vue'</span>

<span class="token keyword">import</span> Vuex <span class="token keyword">from</span> <span class="token string">'vuex'</span>
Vue<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>Vuex<span class="token punctuation">)</span>

<span class="token keyword">const</span> actions <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token function">addOdd</span><span class="token punctuation">(</span><span class="token parameter">context<span class="token punctuation">,</span>value</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>context<span class="token punctuation">.</span>state<span class="token punctuation">.</span>count <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
           context<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">'AddOdd'</span><span class="token punctuation">,</span>value<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">addWait</span><span class="token punctuation">(</span><span class="token parameter">context<span class="token punctuation">,</span>value</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
            context<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">'AddWait'</span><span class="token punctuation">,</span>value<span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> mutations <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token function">Add</span><span class="token punctuation">(</span><span class="token parameter">state<span class="token punctuation">,</span>value</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        state<span class="token punctuation">.</span>count <span class="token operator">+=</span> value
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">Reduce</span><span class="token punctuation">(</span><span class="token parameter">state<span class="token punctuation">,</span>value</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        state<span class="token punctuation">.</span>count <span class="token operator">-=</span> value
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">AddOdd</span><span class="token punctuation">(</span><span class="token parameter">state<span class="token punctuation">,</span>value</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        state<span class="token punctuation">.</span>count <span class="token operator">+=</span> value
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">AddWait</span><span class="token punctuation">(</span><span class="token parameter">state<span class="token punctuation">,</span>value</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        state<span class="token punctuation">.</span>count <span class="token operator">+=</span> value
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">count</span><span class="token operator">:</span><span class="token number">1</span>
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">new</span> <span class="token class-name">Vuex<span class="token punctuation">.</span>Store</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    actions<span class="token punctuation">,</span>
    mutations<span class="token punctuation">,</span>
    state
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>效果</p> <p><img src="https://img-blog.csdnimg.cn/img_convert/dbf1f7ca8da3d3d73c6f1ffd504d0b61.gif" alt=""></p> <h3 id="_6-vuex中的数据在页面刷新后消失怎么办"><a href="#_6-vuex中的数据在页面刷新后消失怎么办" class="header-anchor">#</a> 6.vuex中的数据在页面刷新后消失怎么办?</h3> <p>用sessionstorage 或者 localstorage 存储数据</p> <div class="language- extra-class"><pre class="language-text"><code>&amp;#x5B58;&amp;#x50A8;&amp;#xFF1A; sessionStorage.setItem( '&amp;#x540D;', JSON.stringify(&amp;#x503C;) )
&amp;#x4F7F;&amp;#x7528;&amp;#xFF1A; sessionStorage.getItem('&amp;#x540D;') ---&amp;#x5F97;&amp;#x5230;&amp;#x7684;&amp;#x503C;&amp;#x4E3A;&amp;#x5B57;&amp;#x7B26;&amp;#x4E32;&amp;#x7C7B;&amp;#x578B;&amp;#xFF0C;&amp;#x7528;JSON.parse()&amp;#x53BB;&amp;#x5F15;&amp;#x53F7;&amp;#xFF1B;
</code></pre></div><h2 id="_5-组件通信"><a href="#_5-组件通信" class="header-anchor">#</a> 5.组件通信</h2> <h3 id="_1-vue组件间通信有哪几种方式"><a href="#_1-vue组件间通信有哪几种方式" class="header-anchor">#</a> 1. <strong>vue组件间通信有哪几种方式?</strong></h3> <h4 id="_1-props-emit"><a href="#_1-props-emit" class="header-anchor">#</a> 1. <strong>props/$emit</strong></h4> <p>适用: <strong>父子组件通信</strong></p> <p><strong>父传子</strong>:父组件通过往子组件标签中添加需要传递的数据，子组件使用 <strong>props</strong>来接收, <strong>prop只读，不可修改,即单向数据流</strong></p> <p><strong>子传父</strong>: <code>$emit</code>绑定一个自定义事件, 当这个语句被执行时, 就会将参数arg传递给父组件,父组件通过v-on监听并接收参数</p> <h4 id="_2-ref"><a href="#_2-ref" class="header-anchor">#</a> <strong>2.ref</strong></h4> <p>适用: <strong>父子组件通信</strong></p> <p>如果ref挂载在普通的DOM元素上,引用指向的就是DOM元素;如 <strong>果挂载在子组件上,引用就指向组件实例</strong></p> <p><strong>父组件可以通过this.$ref.xxx来获取子组件实例</strong></p> <h4 id="_3-p-a-r-e-n-t-parent-p-a-r-e-n-t-children"><a href="#_3-p-a-r-e-n-t-parent-p-a-r-e-n-t-children" class="header-anchor">#</a> 3. p a r e n t / parent/p a r e n t / children</h4> <p><img src="https://img-blog.csdnimg.cn/img_convert/6907e9abd1bcfd134c1e9e3f76e7fd0d.webp?x-oss-process=image/format,png" alt=""></p> <p>适用于: <strong>父子组件通信</strong></p> <p>通过 <strong>this.p a r e n t ∗ ∗ 和 ∗ ∗ t h i s . parent</strong>和<strong>this.p a r e n t ∗∗和∗∗t h i s . children</strong>来获取对应的父子组件实例</p> <h4 id="_4-eventbus"><a href="#_4-eventbus" class="header-anchor">#</a> 4.EventBus</h4> <p>适用于: <strong>任意组件间通信</strong></p> <p>这种方法通过一个空的Vue实例作为中央 <strong>事件总线</strong>，用它来触发事件和监听事件，从而实现任意组件之间的通信</p> <p>发布事件:通过$emit来发布事件</p> <p>订阅事件:通过$on来订阅事件,当监听到发布的事件后,执行相应的回调</p> <div class="language-js extra-class"><pre class="language-js"><code>
<span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    <span class="token literal-property property">data</span><span class="token operator">:</span><span class="token punctuation">{</span>

    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token literal-property property">methods</span><span class="token operator">:</span><span class="token punctuation">{</span>
        <span class="token function">emit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>bus<span class="token punctuation">.</span>$emit<span class="token punctuation">.</span><span class="token function">sayhello</span><span class="token punctuation">(</span><span class="token string">'say'</span><span class="token punctuation">,</span><span class="token string">'hello'</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    <span class="token literal-property property">data</span><span class="token operator">:</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">mounted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>bus<span class="token punctuation">.</span><span class="token function">$on</span><span class="token punctuation">(</span><span class="token string">'say'</span><span class="token punctuation">,</span><span class="token keyword">this</span><span class="token punctuation">.</span>say<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token literal-property property">methods</span><span class="token operator">:</span><span class="token punctuation">{</span>
        <span class="token function">say</span><span class="token punctuation">(</span><span class="token parameter">word</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>word<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><blockquote><p>eventBus也有不方便之处, 当项目较大,就容易造成难以维护的灾难</p></blockquote> <h4 id="_5-a-t-t-r-s-attrs-a-t-t-r-s-listeners"><a href="#_5-a-t-t-r-s-attrs-a-t-t-r-s-listeners" class="header-anchor">#</a> 5. a t t r s / attrs/a t t r s / listeners</h4> <p>适用于: <strong>隔代组件通信</strong></p> <p><code>$attrs</code>：包含了父作用域中不被 prop 所识别 (且获取) 的特性绑定 ( class 和 style 除外 )。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 ( class 和 style 除外 )，并且可以通过 <code>v-bind=&quot;$attrs&quot;</code> 传入内部组件。通常配合 inheritAttrs 选项一起使用。</p> <p><code>$listeners</code>：包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 <code>v-on=&quot;$listeners&quot;</code> 传入内部组件</p> <h4 id="_6-provide-inject"><a href="#_6-provide-inject" class="header-anchor">#</a> 6.provide/inject</h4> <p>适用于: <strong>隔代组件通信</strong></p> <p><code>provide</code>/ <code>inject</code> 是 <code>vue2.2.0</code>新增的api, 简单来说就是父组件中通过 <code>provide</code>来提供变量, 然后再子组件中通过 <code>inject</code>来注入变量。</p> <blockquote><p>注意: 这里不论子组件嵌套有多深, 只要调用了 <code>inject</code> 那么就可以注入 <code>provide</code>中的数据，而不局限于只能从当前父组件的props属性中回去数据</p></blockquote> <h3 id="_7-vuex"><a href="#_7-vuex" class="header-anchor">#</a> 7.vuex</h3> <p>适用于: <strong>任意组件间通信</strong></p> <p><strong>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式</strong>。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化. Vuex 解决了 <code>&amp;#x591A;&amp;#x4E2A;&amp;#x89C6;&amp;#x56FE;&amp;#x4F9D;&amp;#x8D56;&amp;#x4E8E;&amp;#x540C;&amp;#x4E00;&amp;#x72B6;&amp;#x6001;</code>和 <code>&amp;#x6765;&amp;#x81EA;&amp;#x4E0D;&amp;#x540C;&amp;#x89C6;&amp;#x56FE;&amp;#x7684;&amp;#x884C;&amp;#x4E3A;&amp;#x9700;&amp;#x8981;&amp;#x53D8;&amp;#x66F4;&amp;#x540C;&amp;#x4E00;&amp;#x72B6;&amp;#x6001;</code>的问题，将开发者的精力聚焦于数据的更新而不是数据在组件之间的传递上</p> <p>Vuex的各个模块:</p> <ul><li><code>state</code>：用于数据的存储，是store中的唯一数据源</li> <li><code>getters</code>：如vue中的计算属性一样，基于state数据的二次包装，常用于数据的筛选和多个数据的相关性计算</li> <li><code>mutations</code>：类似函数，改变state数据的唯一途径，且不能用于处理异步事件</li> <li><code>actions</code>：类似于 <code>mutation</code>，用于提交 <code>mutation</code>来改变状态，而不直接变更状态，可以包含任意异步操作</li> <li><code>modules</code>：类似于命名空间，用于项目中将各个模块的状态分开定义和操作，便于维护</li></ul> <h4 id="_8-localstorage-sessionstorage"><a href="#_8-localstorage-sessionstorage" class="header-anchor">#</a> 8.localStorage/sessionStorage</h4> <p>通过浏览器缓存来实现组件间通信</p> <h2 id="_6-virtual-dom"><a href="#_6-virtual-dom" class="header-anchor">#</a> 6.Virtual DOM</h2> <h3 id="_1-虚拟dom是什么"><a href="#_1-虚拟dom是什么" class="header-anchor">#</a> 1.虚拟dom是什么</h3> <p><strong>虚拟DOM</strong>简而言之就是，用JS去按照DOM结构来实现的树形结构对象，你也可以叫做 <strong>DOM对象</strong></p> <h3 id="_2-为什么需要虚拟dom"><a href="#_2-为什么需要虚拟dom" class="header-anchor">#</a> 2.为什么需要虚拟dom</h3> <p><strong>优点：</strong></p> <ul><li><strong>保证性能下限：</strong> 框架的虚拟 DOM 需要适配任何上层 API 可能产生的操作，它的一些 DOM 操作的实现必须是普适的，所以它的性能并不是最优的；但是比起粗暴的 DOM 操作性能要好很多，因此框架的虚拟 DOM 至少可以保证在你不需要手动优化的情况下，依然可以提供还不错的性能，即保证性能的下限；</li> <li><strong>无需手动操作 DOM：</strong> 我们不再需要手动去操作 DOM，只需要写好 View-Model 的代码逻辑，框架会根据虚拟 DOM 和 数据双向绑定，帮我们以可预期的方式更新视图，极大提高我们的开发效率；</li> <li><strong>跨平台：</strong> 虚拟 DOM 本质上是 JavaScript 对象,而 DOM 与平台强相关，相比之下虚拟 DOM 可以进行更方便地跨平台操作，例如服务器渲染、weex 开发等等。</li></ul> <p><strong>缺点:</strong></p> <ul><li><strong>无法进行极致优化：</strong> 虽然虚拟 DOM + 合理的优化，足以应对绝大部分应用的性能需求，但在一些性能要求极高的应用中虚拟 DOM 无法进行针对性的极致优化。</li></ul> <h3 id="_3-vue的虚拟dom解决了什么问题"><a href="#_3-vue的虚拟dom解决了什么问题" class="header-anchor">#</a> 3.vue的虚拟dom解决了什么问题</h3> <ul><li><strong>无需手动操纵dom</strong></li> <li>虚拟dom可以方便的进行 <strong>跨平台</strong>操作，例如在node环境中无法应用真实dom，但是可以使用虚拟dom</li></ul> <h3 id="_4-虚拟dom的实现原理"><a href="#_4-虚拟dom的实现原理" class="header-anchor">#</a> 4.虚拟DOM的实现原理</h3> <p>虚拟 DOM 的实现原理主要包括以下 3 部分：</p> <ul><li>用 JavaScript 对象模拟真实 DOM 树，对真实 DOM 进行抽象；</li> <li>diff 算法 — 比较两棵虚拟 DOM 树的差异；</li> <li>pach 算法 — 将两个虚拟 DOM 对象的差异应用到真正的 DOM 树。</li></ul> <h2 id="_7-diff"><a href="#_7-diff" class="header-anchor">#</a> 7.diff</h2> <h3 id="_1-实现diff的思路"><a href="#_1-实现diff的思路" class="header-anchor">#</a> 1.实现diff的思路</h3> <ul><li>用JS模拟真实DOM节点</li> <li>把虚拟DOM转换成真实DOM插入页面中</li> <li>发生变化时，比较两棵树的差异，生成差异对象</li> <li>根据差异对象更新真实DOM</li></ul> <p><img src="https://img-blog.csdnimg.cn/img_convert/dd68701797cc68fc70020619eba68102.webp?x-oss-process=image/format,png" alt=""></p> <h4 id="_2-vue中的key的作用"><a href="#_2-vue中的key的作用" class="header-anchor">#</a> 2.vue中的key的作用</h4> <p>1.key是虚拟DOM对象的标识，当数据发生变化时，Vue会根据 <strong>新数据</strong>生成 <strong>新的虚拟DOM</strong>，随后Vue进行 <strong>新虚拟DOM</strong>与 <strong>旧虚拟DOM</strong>的差异比较</p> <p>2.对比规则:</p> <p>​ (1). <strong>旧虚拟DOM</strong>中找到了与 <strong>新虚拟DOM</strong>相同的 <strong>key</strong>:</p> <p>​ ①.若 <strong>虚拟DOM</strong>中内容 <strong>没有变化</strong>，直接使用之前的 <strong>真实DOM</strong></p> <p>​ ②.若 <strong>虚拟DOM</strong>中 <strong>内容变了</strong>，则生成 <strong>新的真实DOM</strong>，随后替换掉页面中之前的 <strong>真实DOM</strong></p> <p>​ (2). <strong>旧虚拟DOM</strong>中未找到与 <strong>新虚拟DOM</strong>相同的 <strong>key</strong></p> <p>​ 创建新的 <strong>真实DOM</strong>,随后渲染到页面</p> <p>3.用 <strong>index</strong>作为 <strong>key</strong>可能会引发的问题:</p> <p>​ (1).若对数据进行 <strong>逆序添加</strong>、 <strong>逆序删除</strong>等 <strong>破坏顺序的操作</strong>会产生 <strong>没有必要的真实DOM更新</strong>，界 面效果没有问题， <strong>但是执行效率很低</strong></p> <p>​ (2).如果结构中还包含 <strong>输入类的DOM</strong>:会产生 <strong>错误DOM更新</strong>， <strong>界面有问题</strong></p> <p>​ 4.开发中如何选择key？</p> <p>​ (1).最好使用 <strong>每条数据的唯一标识</strong>作为 <strong>key</strong>，比如id、手机号、身份证号、学号等唯一值</p> <p>​ (2).如果不存在对数据的 <strong>逆序添加</strong>、 <strong>逆序删除</strong>等 <strong>破坏顺序的操作</strong>，仅用于渲染列表用于展示， <strong>使用index作为key是没有问题的</strong></p> <p><strong>index作为key和id作为key的区别</strong></p> <p><img src="https://img-blog.csdnimg.cn/img_convert/d769631fdad084703011d8849d2ee646.png" alt=""></p> <p><img src="https://img-blog.csdnimg.cn/img_convert/1000c649d4ed9ccde4f36564cbc2f16e.png" alt=""></p> <h2 id="_8-vue-computed-watch"><a href="#_8-vue-computed-watch" class="header-anchor">#</a> 8.Vue computed/watch</h2> <h3 id="_1-computed-和-watch-的区别和运用的场景"><a href="#_1-computed-和-watch-的区别和运用的场景" class="header-anchor">#</a> 1.computed 和 watch 的区别和运用的场景？</h3> <p><strong>computed：</strong> 是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值；</p> <p><strong>watch：</strong> 更多的是「观察」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作；</p> <p><strong>运用场景：</strong></p> <ul><li>当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；</li> <li>当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</li></ul> <h2 id="_9-vue和react有什么不同"><a href="#_9-vue和react有什么不同" class="header-anchor">#</a> 9.Vue和React有什么不同</h2> <h4 id="相同点"><a href="#相同点" class="header-anchor">#</a> 相同点：</h4> <p>1，都使用了 <strong>Virtual DOM</strong>。</p> <p>2，都提供了响应式和组件化的视图组件。</p> <p>3，都将注意力集中保持在核心库，而将其他功能如路由和全局状态管理交给相关库。</p> <h4 id="不同点"><a href="#不同点" class="header-anchor">#</a> 不同点：</h4> <p>1，React中，当某组件的状态发生改变时，它会以该组件为根，重新渲染整个组件子树，而在Vue中，组件的依赖是在渲染的过程中自动追踪的，所以系统能准确知晓哪个组件确实需要被重新渲染。</p> <p>2，Vue的路由库和状态管理库都由官方维护支持且与核心库同步更新，而React选择把这些问题交给社区维护，因此生态更丰富。</p> <p>3，Vue-cli脚手架可进行配置</p> <h3 id="_4-网络"><a href="#_4-网络" class="header-anchor">#</a> 4.网络</h3> <h2 id="_1-http"><a href="#_1-http" class="header-anchor">#</a> 1.HTTP</h2> <h2 id="_2-dns"><a href="#_2-dns" class="header-anchor">#</a> 2.DNS</h2> <h2 id="_3-tcp"><a href="#_3-tcp" class="header-anchor">#</a> 3.TCP</h2> <h2 id="_4-https"><a href="#_4-https" class="header-anchor">#</a> 4.HTTPS</h2> <h2 id="_5-cdn"><a href="#_5-cdn" class="header-anchor">#</a> 5.CDN</h2> <h2 id="_6-从输入url到页面展示发生了什么"><a href="#_6-从输入url到页面展示发生了什么" class="header-anchor">#</a> 6.从输入url到页面展示发生了什么</h2> <p>先来个流程总述：</p> <p>DNS解析：将域名解析成IP地址
TCP连接：TCP三次握手
发送HTTP请求
服务器处理请求并返回HTTP报文
浏览器解析渲染页面
连接结束：TCP四次挥手</p> <h3 id="dns解析"><a href="#dns解析" class="header-anchor">#</a> DNS解析</h3> <p>在浏览器输入URL后，首先要经过域名解析。浏览器通过向 DNS 服务器发送域名，DNS 服务器查询到与域名相对应的 IP 地址，然后返回给浏览器，浏览器再将 IP 地址打在协议上，同时请求参数也会在协议搭载，然后一并发送给对应的服务器。</p> <div class="language- extra-class"><pre><code>1.什么是URL
</code></pre></div><p>URL(Uniform Resource Locator)，统一资源定位符，用于定位互联网上资源，俗称网址。比如 http://www.w3school.com.cn/ht...，
遵守以下的语法规则：
<code>scheme://host.domain:port/path/filename</code>
各部分解释如下：
scheme：定义因特网服务的类型。常见的协议有 http、https、ftp、file，其中最常见的类型是 http，而 https 则是进行加密的网络传输。
host：定义域主机(http 的默认主机是 www)
domain：定义因特网域名，比如 w3school.com.cn
port：定义主机上的端口号(http 的默认端口号是 80)
path： 定义服务器上的路径(如果省略，则文档必须位于网站的根目录中)。
filename： 定义文档/资源的名称
2. 什么是DNS
DNS(domain name system，域名系统)：因特网上域名和IP地址相互映射的分布式数据库；简单理解就是域名与IP地址的对照表，因为域名(如：www.google.com)对于我们而言，更便于记忆，但是机器却不擅长这种表达方式，因此需要将域名转换为IP地址，以便于机器识别， 这便有了DNS。
3. 根域名服务器
根服务器是架设互联网的必须设施，管理互联网的主目录，全球共有13套根域名服务器
4. 递归查询
客户端主机向本地域名服务器的查询是递归查询；所谓递归查询：客户端主机查询的域名地址无法在本地域名服务器中找到，因此本地域名服务器就以DNS客户端的身份向其他根域名服务器发起请求，进行查询，而不是让客户端主机去一直查询；
递归查询的结果要么是返回的IP地址，要么是报错，表示无法查询到地址；
5. 迭代查询
本地域名服务器向根服务器、顶级域名服务器和主机域名服务器发起的查询请求就是迭代的过程，如：本地域名服务器向根服务器发起查询请求，根服务器中会告诉本地域名服务器：”我这里没有你要找的内容，你去顶级域名服务器上找吧“，并将顶级域名服务器的地址返回给本地域名服务器，本地域名服务器接收到后，继续向顶级域名服务器发送请求；顶级域名服务器要么返回ip地址，要么告诉本地域名服务器下一步要向哪个权限域名服务器发送请求，直到找到ip地址或找不到ip返回报错信息，然后信息返回给客户端主机；
下图给出了这两种查询的差别
递归过程：主机→本地DNS服务器→其他DNS服务器(如：我要找一个苹果吃，找到了A，问A有没有，A说我帮你去找B，B可能有，果真B有，然后B将苹果给了A，A再将苹果给我，这就是递归)
迭代过程：本地DNS服务器→根服务器，本地DNS服务器→顶级域名服务器，本地DNS服务器→权限域名服务器；(如：我要找一个苹果，找到了A，A说我也没有，B可能有，你去找B吧；我又找B，B说我也没有，你去找C吧，我又去找C，终于找到了苹果，这就是迭代的过程)
2. 什么是DNS
DNS(domain name system，域名系统)：因特网上域名和IP地址相互映射的分布式数据库；简单理解就是域名与IP地址的对照表，因为域名(如：www.google.com)对于我们而言，更便于记忆，但是机器却不擅长这种表达方式，因此需要将域名转换为IP地址，以便于机器识别， 这便有了DNS。
3. 根域名服务器
根服务器是架设互联网的必须设施，管理互联网的主目录，全球共有13套根域名服务器
4. 递归查询
客户端主机向本地域名服务器的查询是递归查询；所谓递归查询：客户端主机查询的域名地址无法在本地域名服务器中找到，因此本地域名服务器就以DNS客户端的身份向其他根域名服务器发起请求，进行查询，而不是让客户端主机去一直查询；
递归查询的结果要么是返回的IP地址，要么是报错，表示无法查询到地址；
5. 迭代查询
本地域名服务器向根服务器、顶级域名服务器和主机域名服务器发起的查询请求就是迭代的过程，如：本地域名服务器向根服务器发起查询请求，根服务器中会告诉本地域名服务器：”我这里没有你要找的内容，你去顶级域名服务器上找吧“，并将顶级域名服务器的地址返回给本地域名服务器，本地域名服务器接收到后，继续向顶级域名服务器发送请求；顶级域名服务器要么返回ip地址，要么告诉本地域名服务器下一步要向哪个权限域名服务器发送请求，直到找到ip地址或找不到ip返回报错信息，然后信息返回给客户端主机；
下图给出了这两种查询的差别
递归过程：主机→本地DNS服务器→其他DNS服务器(如：我要找一个苹果吃，找到了A，问A有没有，A说我帮你去找B，B可能有，果真B有，然后B将苹果给了A，A再将苹果给我，这就是递归)
迭代过程：本地DNS服务器→根服务器，本地DNS服务器→顶级域名服务器，本地DNS服务器→权限域名服务器；(如：我要找一个苹果，找到了A，A说我也没有，B可能有，你去找B吧；我又找B，B说我也没有，你去找C吧，我又去找C，终于找到了苹果，这就是迭代的过程)</p> <h3 id="tcp连接-tcp三次握手"><a href="#tcp连接-tcp三次握手" class="header-anchor">#</a> TCP连接：TCP三次握手</h3> <p>在客户端发送数据之前会发起 TCP 三次握手用以同步客户端和服务端的序列号和确认号，并交换 TCP 窗口大小信息。</p> <p>说明：
Ack：应答
Fin：结束; 结束会话
Seq： 一个数据段的第一个序列号
SYN： 同步; 表示开始会话请求
复制代码
第一次握手：客户端A将标志位SYN置为1,随机产生一个值为seq=X(X的取值范围为=1234567)的数据包到服务器，客户端A进入SYN_SENT状态，等待服务端B确认(第一次握手，由浏览器发起，告诉服务器我要发送请求了)；
第二次握手：服务端B收到数据包后由标志位SYN=1知道客户端A请求建立连接，服务端B将标志位SYN和ACK都置为1，ack=X+1，随机产生一个值seq=Y，并将该数据包发送给客户端A以确认连接请求，服务端B进入SYN_RCVD状态(第二次握手，由服务器发起，告诉浏览器我准备接受了，你赶紧发送吧)。
第三次握手：客户端A收到确认后，检查ack是否为X+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=Y+1，并将该数据包发送给服务端B，服务端B检查ack是否为Y+1，ACK是否为1，如果正确则连接建立成功，客户端A和服务端B进入ESTABLISHED状态，完成三次握手，随后客户端A与服务端B之间可以开始传输数据了(第三次握手，由浏览器发送，告诉服务器，我马上就发了，准备接受吧)。
为什需要三次握手？ 计算机网络》第四版中讲“三次握手”的目的是“为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误”。 书中的例子是这样的，“已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。 假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。”。主要目的防止server端一直等待，浪费资源。</p> <h3 id="浏览器向web服务器发送http请求"><a href="#浏览器向web服务器发送http请求" class="header-anchor">#</a> 浏览器向web服务器发送HTTP请求</h3> <p>TCP三次握手之后，开始发送HTTP请求报文至服务器</p> <p>HTTP请求报文格式：请求行+请求头+空行+消息体，请求行包括请求方式(GET/POST/DELETE/PUT)、请求资源路径(URL)、HTTP版本号；</p> <h3 id="服务器处理请求并返回http报文"><a href="#服务器处理请求并返回http报文" class="header-anchor">#</a> 服务器处理请求并返回HTTP报文</h3> <p>服务器收到请求后会发出应答，即响应数据。HTTP响应与HTTP请求相似， HTTP响应报文格式：状态行+响应头+空行+消息体，状态行包括HTTP版本号、状态码、状态说明。</p> <h3 id="浏览器解析渲染页面"><a href="#浏览器解析渲染页面" class="header-anchor">#</a> 浏览器解析渲染页面</h3> <p>浏览器拿到响应文本后，解析HTML代码，请求js，css等资源，最后进行页面渲染，呈现给用户。页面渲染一般分为以下几个步骤：</p> <p>(1)根据HTML文件解析出DOM Tree</p> <p>(2)根据CSS解析出 CSSOM Tree(CSS规则树)</p> <p>(3)将 DOM Tree 和 CSSOM Tree合并，构建Render tree(渲染树)</p> <p>(4)reflow(重排)：根据Render tree进行节点信息计算(Layout)</p> <p>(5)repaint(重绘)：根据计算好的信息绘制整个页面(Painting)</p> <h3 id="tcp四次挥手。"><a href="#tcp四次挥手。" class="header-anchor">#</a> TCP四次挥手。</h3> <p>当数据传输完毕，需要断开TCP连接，此时发起tcp四次挥手</p> <p>1、客户端向服务端发送报文，Fin、Ack、Seq，表示已经没有数据传输了。并进入 FIN_WAIT_1 状态。(由浏览器告诉服务器，我请求报文发送完了，你准备关闭吧)
2、服务端向客户端发送报文，Ack、Seq，表示同意关闭请求。此时主机发起方进入 FIN_WAIT_2 状态。(由服务器告诉浏览器，我请求报文接受完了，我准备关闭了，你也准备吧)</p> <p>3、服务端向客户端发送报文段，Fin、Ack、Seq，请求关闭连接。并进入 LAST_ACK 状态。(由服务器告诉浏览器，我响应报文发送完了，你准备关闭吧)</p> <p>4、客户端向服务端发送报文段，Ack、Seq。然后进入等待 TIME_WAIT 状态。被动方收到发起方的报文段以后关闭连接。发起方等待一定时间未收到回复，则正常关闭。(由浏览器告诉服务器，我响应报文接受完了，我准备关闭了，你也准备吧)</p> <p>简单说就是：</p> <p>1、A——&gt;B ：A告诉B：“我发完了”；</p> <p>2、B——&gt;A：B告诉A：“好的，我知道你发完了”</p> <p>3、B——&gt;A：B告诉A：“我收完了”；</p> <p>4、A——&gt;B：A告诉B：“好的，我知道你发收完了”</p></div> <footer class="page-edit" style="display:none;"><!----> <div class="last-updated"><span class="prefix">2021-04-07: </span> <span class="time">5/23/2023, 10:43:59 PM</span></div></footer> <!----> <!----></main> <!----> <div class="comments-wrapper" data-v-4698c43e><!----></div></div></div></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-44bd5a18 data-v-44bd5a18><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-44bd5a18><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-44bd5a18></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-44bd5a18></path></svg></div></div></div>
    <script src="/assets/js/app.61e9cc92.js" defer></script><script src="/assets/js/3.95481a90.js" defer></script><script src="/assets/js/1.1954234d.js" defer></script><script src="/assets/js/53.a90f2ab6.js" defer></script>
  </body>
</html>
